/* flex definitions section
----------------------------------------------------------------------*/
%option noyywrap nounput batch noinput 8bit full

%{
  #include "../scanner.h"
  #include "../driver.h"
  #include "parser.hpp"
  #include <cerrno>
  #include <climits>
  #include <cfloat>
  #include <cstdlib>
  #include <string>

 // Work around an incompatibility in flex (at least versions
 // 2.5.31 through 2.5.33): it generates code that does
 // not conform to C89.  See Debian bug 333231
 // <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.
 #undef yywrap
 #define yywrap() 1

 // an action which is always executed prior to the matched rule's action
 #define YY_USER_ACTION  loc.columns(yyleng);

 /* yylex_raw is the free function of the lex family of function which's
 definition is generated by flex. See also yylex and the class Scanner */
 #define YY_DECL yy::Parser::symbol_type yylex_raw(Driver& driver)

 using namespace std;
 using namespace yy;
 yy::location loc;
 void yyinitializeParserLoc(string* filename) {
   loc.initialize(filename);
 }

 int charCount(const char*, char ch);
%}

  /* identifier */
ID [a-zA-Z_][a-zA-Z_0-9]*

/* rules section
----------------------------------------------------------------------*/
%%

  // code which is to be executed whenever the scanning routine is entered
%{
  loc.step();
%}

  /* comments and blanks. They are all skiped and thus produce no token. */
\/\/[^\n]*          loc.step();
#![^\n]*            loc.step();
\/\*[^*]*(\*+[^#*]+)*\*+\/  loc.step(); loc.lines(charCount(yytext, '\n'));
[ \t]+              loc.step();
[\n]+               loc.lines(yyleng); loc.step(); return yy::Parser::make_NEWLINE(loc);
\\[ \t]*((\/\/|#!)[^\n]*)?\n		loc.lines(1); loc.step();

  /* non-type keywords */
if\(                return yy::Parser::make_IF_LPAREN(loc);
if                  return yy::Parser::make_IF(loc);
then                return yy::Parser::make_THEN(loc);
elif                return yy::Parser::make_ELIF(loc);
else                return yy::Parser::make_ELSE(loc);
while\(             return yy::Parser::make_WHILE_LPAREN(loc);
while               return yy::Parser::make_WHILE(loc);
do                  return yy::Parser::make_DO(loc);
fun\(               return yy::Parser::make_FUN_LPAREN(loc);
fun                 return yy::Parser::make_FUN(loc);
val\(               return yy::Parser::make_VAL_LPAREN(loc);
val                 return yy::Parser::make_VAL(loc);
var\(               return yy::Parser::make_VAR_LPAREN(loc);
var                 return yy::Parser::make_VAR(loc);
end                 return yy::Parser::make_END(loc);
endof               return yy::Parser::make_ENDOF(loc);
not                 return yy::Parser::make_NOT(loc);
and                 return yy::Parser::make_AND(loc);
or                  return yy::Parser::make_OR(loc);
raw_new\(           return yy::Parser::make_RAW_NEW_LPAREN(loc);
raw_new             return yy::Parser::make_RAW_NEW(loc);
raw_delete\(        return yy::Parser::make_RAW_DELETE_LPAREN(loc);
raw_delete          return yy::Parser::make_RAW_DELETE(loc);
nop                 return yy::Parser::make_NOP(loc);
return\(            return yy::Parser::make_RETURN_LPAREN(loc);
return              return yy::Parser::make_RETURN(loc);
mut                 return yy::Parser::make_MUT(loc);
is                  return yy::Parser::make_IS(loc);
static              return yy::Parser::make_STATIC(loc);
local               return yy::Parser::make_LOCAL(loc);
noinit              return yy::Parser::make_NOINIT(loc);


  /* type keywords */
void                return yy::Parser::make_FUNDAMENTAL_TYPE(ObjTypeFunda::eVoid, loc);
char                return yy::Parser::make_FUNDAMENTAL_TYPE(ObjTypeFunda::eChar, loc);
int                 return yy::Parser::make_FUNDAMENTAL_TYPE(ObjTypeFunda::eInt, loc);
bool                return yy::Parser::make_FUNDAMENTAL_TYPE(ObjTypeFunda::eBool, loc);
double              return yy::Parser::make_FUNDAMENTAL_TYPE(ObjTypeFunda::eDouble, loc);


  /* literal bool */
false               return yy::Parser::make_NUMBER(NumberToken(0, ObjTypeFunda::eBool), loc);
true                return yy::Parser::make_NUMBER(NumberToken(1, ObjTypeFunda::eBool), loc);


  /* literal char */
'.'                 return yy::Parser::make_NUMBER(NumberToken(yytext[1], ObjTypeFunda::eChar), loc);


  /* literal integral / floatingpoint number  */
[0-9]+(\.[0-9]+)?{ID}?  {
  errno = 0;
  char* suffix = nullptr;
  bool containsDot = (nullptr != strchr(yytext, '.'));
  long double number = strtold(yytext, &suffix);
  ObjTypeFunda::EType objType = ObjTypeFunda::eVoid;

  if (errno) {
    driver.exitInternError(loc, string("Scanner's rule"
     "matched a number, but strtol doesn't recognize a number. ") +
     strerror(errno));

  // currently no suffixes are recognized
  } else if (*suffix!='\0') {
    driver.error(loc, string("Unknown literal number suffix: ") + suffix);
  }

  // it's an floating point literal
  else if (containsDot) {
    if (number<DBL_MIN || number>DBL_MAX) {
      number = number<DBL_MIN ? DBL_MIN : DBL_MAX;
      driver.error(loc, "Numeric literal to big");
    }
    objType = ObjTypeFunda::eDouble;
  }

  // it's an integral literal
  else {
    if (number<INT_MIN || number>INT_MAX) {
      number = number<INT_MIN ? INT_MIN : INT_MAX;
      driver.error(loc, "Numeric literal to big");
    }
    objType = ObjTypeFunda::eInt;
  }
  return yy::Parser::make_NUMBER(
    NumberToken(static_cast<GeneralValue>(number), objType), loc);
}

  /* punctuation */
":="                return yy::Parser::make_COLON_EQUAL(loc);
"->"                return yy::Parser::make_ARROW(loc);
"&&"                return yy::Parser::make_AMPER_AMPER(loc);
"||"                return yy::Parser::make_PIPE_PIPE(loc);
"=="                return yy::Parser::make_EQUAL_EQUAL(loc);
"=<"                return yy::Parser::make_EQUAL_LESS(loc);
"(="                return yy::Parser::make_LPAREN_EQUAL(loc);
op([-+*/!]|&&|"||"|"=="|"_and"|"_or"|"_not"|"_new"|"_delete") {
  char* start = yytext + 2;     // skip "op"
  if (*start == '_') ++start;   // skip '_'
  return yy::Parser::make_OP_NAME(start, loc);
}

";"                 return yy::Parser::make_SEMICOLON(loc);
"$"                 return yy::Parser::make_DOLLAR(loc);
":"                 return yy::Parser::make_COLON(loc);
","                 return yy::Parser::make_COMMA(loc);
"+"                 return yy::Parser::make_PLUS(loc);
"-"                 return yy::Parser::make_MINUS(loc);
"*"                 return yy::Parser::make_STAR(loc);
"&"                 return yy::Parser::make_AMPER(loc);
"/"                 return yy::Parser::make_SLASH(loc);
"!"                 return yy::Parser::make_EXCL(loc);
"="                 return yy::Parser::make_EQUAL(loc);
"("                 return yy::Parser::make_LPAREN(loc);
")"                 return yy::Parser::make_RPAREN(loc);
"{"                 return yy::Parser::make_LBRACE(loc);
"}"                 return yy::Parser::make_RBRACE(loc);

  /* misc */
{ID}                return yy::Parser::make_ID(yytext, loc);
<<EOF>>             return yy::Parser::make_END_OF_FILE(loc);
.                   driver.error(loc, "invalid character");

%%
/* user code section
----------------------------------------------------------------------*/
Scanner::Scanner(Driver& driver) :
  m_driver(driver) {
}

Parser::symbol_type Scanner::pop() {
  return yylex_raw(m_driver);
}

int charCount(const char* p, char ch) {
  int cnt = 0;
  for ( /*nop*/; *p!='\0'; ++p) {
    if (*p==ch) {
      ++cnt;
    }
  }
  return cnt;
}
