cmake_minimum_required(VERSION 2.8.8)

# gobal
# --------------------------------------------------
enable_testing()

# experiment
# add_definitions(-Weverything -Wno-c++98-compat -Wno-covered-switch-default
#   -Wno-undef -Wreserved-id-macro -Wno-padded -Wno-weak-vtables
#   -Wno-global-constructors -Wno-exit-time-destructors
#   -Wno-documentation-unknown-command)
# Wno-unused-parameter is due to llvm headers
add_definitions(-std=c++14 -Wall -Wextra -Wpedantic -Wno-unused-parameter -Werror)


# efc - EF compiler
# --------------------------------------------------
find_package(LLVM REQUIRED)
find_package(BISON REQUIRED)
find_package(FLEX REQUIRED)

# generate parser and scanner source code
set(EFC_GEN_SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/gensrc)
bison_target(parser parser.yy ${EFC_GEN_SRC_DIR}/parser.cpp
  COMPILE_FLAGS "--verbose -x -g -Werror --warnings=all")
flex_target(scanner scanner.l ${EFC_GEN_SRC_DIR}/scanner.cpp)
add_flex_bison_dependency(scanner parser)

# if possible, generate parser.xhtml from parser.xml via xsltproc

# TODO: parser.xhtml is NOT build if building parser.cpp fails (but parser.xml
#       _is_ built). Maybe due to ${BISON_parser_OUTPUTS} containing also
#       parser.cpp.  But if I replace that by ${EFC_GEN_SRC_DIR}/parser.xml,
#       xsltproc throws many funny errors at me, maybe because it is called
#       before the xml is fully generated.
find_program(XSLTPROC xsltproc)
if (NOT XSLTPROC)
  message(WARNING "xsltproc not found. With apt, you can install it with 'apt-get install xsltproc'.")
endif()
if (XSLTPROC)
  # If bison fails due to shift/reduce conflicts, it would be valuable to be
  # able to inspect the parser.html generateable from parser.xml. The parser.xml
  # is generated by bison also in case of shift/reduce conflicts.

  execute_process(
    COMMAND ${BISON_EXECUTABLE} --print-datadir
    OUTPUT_VARIABLE BISON_DATA_DIR
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  # Every time bison runs, it produces a new parser.xml. So we can also always
  # produce a new parser.xhtml out of parser.xml every time bison runs.
  #
  # However it's diffucult to do that in a nice and proper way for the following
  # reasons.
  #
  # - bison_target(...) does not define parser.xml as an output. Also, if
  #   building the bison target fails due to shift/reduce conflicts, parser.cpp/.h
  #   is _not_ produced and the target is considered unsuccessful. However the
  #   parser.xml was still produced, only that CMake can't know about that.
  #
  # - bison_target(...) does not define any target (it only uses
  #   add_custom_command). Thus we can't use "add_custom_target(TARGET parser
  #   POST_BUILD ...)".
  #
  # So the kludge is to run bison again, just that we have a way of knowing when
  # to produce parser.xhtml. But that is not trivial either, because we have to
  # run xsltproc despite that bison fails. Note that when you state multiple
  # COMMAND in add_custom_command, the execution aborts once one of those
  # commands fails. Note that if you make a dependency chain with
  # add_custom_command s and add_customo_target s, then execution also aborts
  # once a command fails.
  add_custom_command(
    OUTPUT ${EFC_GEN_SRC_DIR}/parser.xhtml
    DEPENDS parser.yy
    COMMAND
      ${BISON_EXECUTABLE} -x -o ${CMAKE_CURRENT_BINARY_DIR}/dummy_parser.cpp parser.yy
        2> /dev/null > /dev/null # bison is already run the 'official' way, we don't
                                 # want to see its output again. Using &> resulted
                                 # in a failing xsltproc for unknown reasons.
      ";" # run xsltproc always, independent of bison's exit status
      ${XSLTPROC} -o ${EFC_GEN_SRC_DIR}/parser.xhtml
        ${BISON_DATA_DIR}/xslt/xml2xhtml.xsl ${CMAKE_CURRENT_BINARY_DIR}/dummy_parser.xml
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    )
  add_custom_target(efc-parser-xhtml ALL
    DEPENDS ${EFC_GEN_SRC_DIR}/parser.xhtml
    )
endif()

set(SRCS
  ast.cpp
  astdefaultiterator.cpp
  astprinter.cpp
  driver.cpp
  efc.cpp
  env.cpp
  envinserter.cpp
  envnode.cpp
  errorhandler.cpp
  executionengineadapter.cpp
  freefromastobject.cpp
  irgen.cpp
  irgenforwarddeclarator.cpp
  object.cpp
  objtype.cpp
  parserapiext.cpp
  parserext.cpp
  semanticanalizer.cpp
  signatureaugmentor.cpp
  storageduration.cpp
  tokenfilter.cpp
  tokenstreamlookahead.cpp
)

add_library(efc_as_lib ${SRCS} ${BISON_parser_OUTPUTS} ${FLEX_scanner_OUTPUTS})
target_include_directories(efc_as_lib PUBLIC ${LLVM_INCLUDE_DIRS})
target_compile_definitions(efc_as_lib PUBLIC ${LLVM_DEFINITIONS})
llvm_map_components_to_libnames(llvm_libs core mcjit x86codegen x86asmparser x86asmprinter)
target_link_libraries(efc_as_lib PUBLIC ${llvm_libs})

add_executable(efc efc.cpp)
target_link_libraries(efc efc_as_lib)


# efc test
# --------------------------------------------------
find_program(TESTDOX testdox)
if (NOT TESTDOX)
  message(FATAL_ERROR "testdox not found. Available at https://github.com/sensorflo/testdox.")
endif()

add_subdirectory(test/googletest/googletest)

set(TEST_TEST_SRCS
  test/tests/tutorialstest.cpp
  test/tests/astprintertest.cpp
  test/tests/asttest.cpp
  test/tests/tokenstreamlookaheadtest.cpp
  test/tests/envtest.cpp
  test/tests/tokenfiltertest.cpp
  test/tests/errorhandlertest.cpp
  test/tests/semanticanalizertest.cpp
  test/tests/objtypetest.cpp
  test/tests/irgentest.cpp
  test/tests/scannerandparsertest.cpp
  test/tests/driversystemtest.cpp
  test/tests/testhelpers/literaltokenstreamtest.cpp
  test/tests/scannertest.cpp
  test/tests/parserexttest.cpp
)
set(TEST_OTHER_SRCS
  test/efctest.cpp
  test/test.cpp

  test/testhelpers/tokentesthelper.cpp
  test/testhelpers/literaltokenstream.cpp
  )

add_executable(efc_test ${TEST_TEST_SRCS} ${TEST_OTHER_SRCS})
target_include_directories(efc_test PRIVATE test test/testhelpers)
target_link_libraries(efc_test PRIVATE efc_as_lib gtest)

# TODO: pass path to testdox and to doc/tutorial dir as parameter
# TODO: make adding an entry to PATH more portable
# TODO: testdox should not be a strict requirement
add_test(efc_test efc_test)
# Set PATH in order that the "#!/usr/bin/env efc" in the tutorials
# (doc/tutorial) finds the efc executable.
set_property(TEST efc_test PROPERTY ENVIRONMENT "PATH=$ENV{PATH}:${CMAKE_CURRENT_BINARY_DIR}")


# generate human readable specifications from test sources
# --------------------------------------------------
find_program(ASCIIDOC asciidoc)
if (NOT ASCIIDOC)
  message(WARNING "asciidoc not found. With apt, you can install it with 'apt-get install asciidoc'.")
endif()
if (TESTDOX AND ASCIIDOC)
  set(_spec_html ${CMAKE_CURRENT_SOURCE_DIR}/test/generated_spec.html)
  add_custom_command(
    OUTPUT ${_spec_html}
    DEPENDS ${TEST_TEST_SRCS}
    COMMAND ${TESTDOX} -f asciidoc ${TEST_TEST_SRCS} > ${CMAKE_CURRENT_BINARY_DIR}/dummy.txt
    COMMAND ${ASCIIDOC} -a toc -o ${_spec_html} ${CMAKE_CURRENT_BINARY_DIR}/dummy.txt
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    VERBATIM
    )
  add_custom_target(
    efc-test-spec-html ALL
    DEPENDS ${_spec_html}
    )
endif()
