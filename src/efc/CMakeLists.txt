cmake_minimum_required(VERSION 2.8.8)

# efc - EF compiler
# --------------------------------------------------
find_package(LLVM REQUIRED)
find_package(BISON REQUIRED)
find_package(FLEX REQUIRED)

# generate parser and scanner source code
set(EFC_GEN_SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/gensrc)
set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${EFC_GEN_SRC_DIR})
bison_target(genparser genparser.yy ${EFC_GEN_SRC_DIR}/genparser.cpp
  COMPILE_FLAGS "--verbose -x -g -Werror --warnings=all")
flex_target(genscanner genscanner.l ${EFC_GEN_SRC_DIR}/genscanner.cpp)
add_flex_bison_dependency(genscanner genparser)

# if possible, generate genparser.xhtml from genparser.xml via xsltproc

# TODO: genparser.xhtml is NOT build if building genparser.cpp fails (but
#       genparser.xml _is_ built). Maybe due to ${BISON_genparser_OUTPUTS}
#       containing also genparser.cpp.  But if I replace that by
#       ${EFC_GEN_SRC_DIR}/parser.xml, xsltproc throws many funny errors at me,
#       maybe because it is called before the xml is fully generated.
find_program(XSLTPROC xsltproc)
if (NOT XSLTPROC)
  message(WARNING "xsltproc not found. With apt, you can install it with 'apt-get install xsltproc'.")
endif()
if (XSLTPROC)
  # If bison fails due to shift/reduce conflicts, it would be valuable to be
  # able to inspect the genparser.html generateable from genparser.xml. The
  # genparser.xml is generated by bison also in case of shift/reduce conflicts.

  execute_process(
    COMMAND ${BISON_EXECUTABLE} --print-datadir
    OUTPUT_VARIABLE BISON_DATA_DIR
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  # Every time bison runs, it produces a new genparser.xml. So we can also always
  # produce a new genparser.xhtml out of genparser.xml every time bison runs.
  #
  # However it's diffucult to do that in a nice and proper way for the following
  # reasons.
  #
  # - bison_target(...) does not define genparser.xml as an output. Also, if
  #   building the bison target fails due to shift/reduce conflicts, genparser.cpp/.h
  #   is _not_ produced and the target is considered unsuccessful. However the
  #   genparser.xml was still produced, only that CMake can't know about that.
  #
  # - bison_target(...) does not define any target (it only uses
  #   add_custom_command). Thus we can't use "add_custom_target(TARGET genparser
  #   POST_BUILD ...)".
  #
  # So the kludge is to run bison again, just that we have a way of knowing when
  # to produce genparser.xhtml. But that is not trivial either, because we have to
  # run xsltproc despite that bison fails. Note that when you state multiple
  # COMMAND in add_custom_command, the execution aborts once one of those
  # commands fails. Note that if you make a dependency chain with
  # add_custom_command s and add_customo_target s, then execution also aborts
  # once a command fails.
  add_custom_command(
    OUTPUT ${EFC_GEN_SRC_DIR}/genparser.xhtml
    DEPENDS genparser.yy
    COMMAND
      ${BISON_EXECUTABLE} -x -o ${CMAKE_CURRENT_BINARY_DIR}/dummy_genparser.cpp genparser.yy
        2> /dev/null > /dev/null # bison is already run the 'official' way, we don't
                                 # want to see its output again. Using &> resulted
                                 # in a failing xsltproc for unknown reasons.
      ";" # run xsltproc always, independent of bison's exit status
      ${XSLTPROC} -o ${EFC_GEN_SRC_DIR}/genparser.xhtml
        ${BISON_DATA_DIR}/xslt/xml2xhtml.xsl ${CMAKE_CURRENT_BINARY_DIR}/dummy_genparser.xml
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    )
  add_custom_target(efc-genparser-xhtml ALL
    DEPENDS ${EFC_GEN_SRC_DIR}/genparser.xhtml
    )
endif()

set(SRCS
  ast.cpp
  astdefaultiterator.cpp
  astprinter.cpp
  driver.cpp
  efc.cpp
  env.cpp
  envinserter.cpp
  envnode.cpp
  errorhandler.cpp
  executionengineadapter.cpp
  freefromastobject.cpp
  irgen.cpp
  irgenforwarddeclarator.cpp
  object.cpp
  object_irpart.cpp
  objtype.cpp
  objtype2.cpp
  objtypetemplate.cpp
  parser.cpp
  scanner.cpp
  genparserext.cpp
  semanticanalizer.cpp
  templateinstanciator.cpp
  storageduration.cpp
  tokenfilter.cpp
  tokenstreamlookahead.cpp
  location.cpp
)

add_library(efc_as_lib ${SRCS} ${BISON_genparser_OUTPUTS} ${FLEX_genscanner_OUTPUTS})
target_include_directories(efc_as_lib PUBLIC ${LLVM_INCLUDE_DIRS})
target_compile_definitions(efc_as_lib PUBLIC ${LLVM_DEFINITIONS})
llvm_map_components_to_libnames(llvm_libs core mcjit x86codegen x86asmparser x86asmprinter)
target_link_libraries(efc_as_lib PUBLIC ${llvm_libs})

add_executable(efc efc.cpp)
target_link_libraries(efc efc_as_lib)


# efc test
# --------------------------------------------------
find_program(TESTDOX testdox)
if (NOT TESTDOX)
  message(FATAL_ERROR "testdox not found. Available at https://github.com/sensorflo/testdox.")
endif()

set(TEST_TEST_SRCS
  test/tests/tutorialstest.cpp
  test/tests/astprintertest.cpp
  test/tests/asttest.cpp
  test/tests/tokenstreamlookaheadtest.cpp
  test/tests/envtest.cpp
  test/tests/tokenfiltertest.cpp
  test/tests/errorhandlertest.cpp
  test/tests/semanticanalizertest.cpp
  test/tests/objtypetest.cpp
  test/tests/irgentest.cpp
  test/tests/scannerandparsertest.cpp
  test/tests/driversystemtest.cpp
  test/tests/testhelpers/literaltokenstreamtest.cpp
  test/tests/scannertest.cpp
  test/tests/genparserexttest.cpp
)
set(TEST_OTHER_SRCS
  test/efctest.cpp
  test/test.cpp

  test/testhelpers/tokentesthelper.cpp
  test/testhelpers/literaltokenstream.cpp
  )

add_executable(efc_test ${TEST_TEST_SRCS} ${TEST_OTHER_SRCS})
target_include_directories(efc_test PRIVATE test test/testhelpers)
target_link_libraries(efc_test PRIVATE efc_as_lib gtest gmock)

# TODO: pass path to testdox and to doc/tutorial dir as parameter
# TODO: make adding an entry to PATH more portable
# TODO: testdox should not be a strict requirement
add_test(NAME efc_test
  COMMAND "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/efc_test")
# Set PATH in order that the "#!/usr/bin/env efc" in the tutorials
# (doc/tutorial) finds the efc executable.
set_property(TEST efc_test PROPERTY ENVIRONMENT "PATH=$ENV{PATH}:${CMAKE_RUNTIME_OUTPUT_DIRECTORY}")


# generate human readable specifications from test sources
# --------------------------------------------------
find_program(ASCIIDOC asciidoc)
if (NOT ASCIIDOC)
  message(WARNING "asciidoc not found. With apt, you can install it with 'apt-get install asciidoc'.")
endif()
if (TESTDOX AND ASCIIDOC)
  set(_spec_html ${CMAKE_CURRENT_SOURCE_DIR}/test/generated_spec.html)
  add_custom_command(
    OUTPUT ${_spec_html}
    DEPENDS ${TEST_TEST_SRCS}
    COMMAND ${TESTDOX} -f asciidoc ${TEST_TEST_SRCS} > ${CMAKE_CURRENT_BINARY_DIR}/dummy.txt
    COMMAND ${ASCIIDOC} -a toc -o ${_spec_html} ${CMAKE_CURRENT_BINARY_DIR}/dummy.txt
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    VERBATIM
    )
  add_custom_target(
    efc-test-spec-html ALL
    DEPENDS ${_spec_html}
    )
endif()
