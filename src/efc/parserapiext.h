#pragma once
#include "declutils.h"
#include "gensrc/parser.hpp"
#include <vector>
#include <iostream>

/** Extends the public API of the class yy::Parser.

\internal The class yy::Parser is generated by Bison. The author of
ParserApiExt did not see a way to configure Bison such that the features
provided by ParserApiExt are directly provided by yy::Parser.

ParserExt is similar, but extends the private implementation details of
Parser. */
class ParserApiExt final {
public:
  enum TokenClass {
    TKStarter,
    TKSeparator,
    TKDelimiter,
    TKComponentOrAmbigous,
    TKNewline,
  };
  static void initTokenAttrs();

  static const char* tokenName(yy::Parser::token_type t);
  static TokenClass tokenClass(yy::Parser::token_type t);

  template<typename SemanticValueType>
  static yy::Parser::symbol_type makeTokenT(yy::Parser::token_type tt);
  static yy::Parser::symbol_type makeToken(yy::Parser::token_type tt);

private:
  ParserApiExt() = delete;
  ~ParserApiExt() = delete;
  NEITHER_COPY_NOR_MOVEABLE(ParserApiExt);

  enum SemanticValueType {
    SVTInvalid,
    SVTVoid,
    SVTFundamentalType,
    SVTString,
    SVTNumberToken
  };
  struct TokenTypeAttr {
    TokenTypeAttr(const char* name, SemanticValueType svt, TokenClass tc);
    TokenTypeAttr();
    const char* m_name;
    SemanticValueType m_semanticValueType;
    TokenClass m_tokenClass;
  };
  /** Redundant copy information allready stored in yy::Parser.

  m_TokenAttrs[].m_name is redundant to yy::Parser::yytname_. The author did
  not knew how to access the private member yy::Parser::yytname_ to be able to
  print tokens. A redundant copy seemed the best among all the bad solutions
  since the tokens do not change that often

  mapping Parser::token_type -> semantic data type is redundant to Bison's
  %token declarations which define the data type of sematic values. Thus
  also redundant to various fragments in the generated files parser.hpp /
  parser.cpp. The author did not see any possibility to make use of
  anything within parser.hpp / parser.cpp. */
  static std::vector<TokenTypeAttr> m_TokenAttrs;
  static std::vector<char> m_OneCharTokenNames;
};

namespace yy {
std::basic_ostream<char>& operator<<(
  std::basic_ostream<char>& os, yy::Parser::token_type t);
}

namespace std {
std::basic_ostream<char>& operator<<(std::basic_ostream<char>& os,
  const std::vector<yy::Parser::token_type>& tokens);
}
