#pragma once
#include "astforwards.h"
#include "declutils.h"
#include "genparserext.h"
#include "gensrc/genparser.hpp"

#include <iostream>
#include <memory>
#include <string>
#include <vector>

class Env;
class ErrorHandler;

/** Wraps the generated parser. That includes the API intended for the scanner /
tokenstream and the API intended for the driver.

\internal The class yy::GenParser is generated by Bison. The author of
Parser did not see a way to configure Bison such that the features provided by
Parser are directly provided by yy::Parser.

Note that there's also ParserExt which extends the private implementation
details of the generated parser. */
class Parser final : public yy::GenParser {
public:
  Parser(std::string& fileName, TokenStream& tokenStream, Env& env,
    ErrorHandler& errorHandler);
  ~Parser() override;

  enum TokenClass {
    TKStarter,
    TKSeparator,
    TKDelimiter,
    TKComponentOrAmbigous,
    TKNewline,
  };

  struct Result {
    /** from generated parser */
    int m_errorCode;
    std::unique_ptr<AstNode> m_astRoot;
  };

  Result parse_();

  /** Guarantess to return non-null */
  std::unique_ptr<AstObject> addImplicitMain(std::unique_ptr<AstNode> ast);

  static void initTokenAttrs();

  static const char* tokenName(Parser::token_type t);
  static TokenClass tokenClass(Parser::token_type t);

  static Parser::symbol_type makeToken(Parser::token_type tt);

private:
  NEITHER_COPY_NOR_MOVEABLE(Parser);

  enum SemanticValueType {
    SVTInvalid,
    SVTVoid,
    SVTFundamentalType,
    SVTString,
    SVTNumberToken
  };

  struct TokenTypeAttr {
    TokenTypeAttr(const char* name, SemanticValueType svt, TokenClass tc);
    TokenTypeAttr();
    const char* m_name;
    SemanticValueType m_semanticValueType;
    TokenClass m_tokenClass;
  };

  int parse() override { return yy::GenParser::parse(); };

  /** Redundant copy information allready stored in GenParser.

  m_TokenAttrs[].m_name is redundant to GenParser::yytname_. The author did
  not knew how to access the private member GenParser::yytname_ to be able to
  print tokens. A redundant copy seemed the best among all the bad solutions
  since the tokens do not change that often

  mapping Parser::token_type -> semantic data type is redundant to Bison's
  %token declarations which define the data type of sematic values. Thus
  also redundant to various fragments in the generated files parser.hpp /
  parser.cpp. The author did not see any possibility to make use of
  anything within parser.hpp / parser.cpp. */
  static std::vector<TokenTypeAttr> m_TokenAttrs;
  static std::vector<char> m_OneCharTokenNames;

  ErrorHandler& m_errorHandler;
  /** Guaranteed to be non-nullptr */
  GenParserExt m_genParserExt;
  std::unique_ptr<AstNode> m_astRootFromParser;
  bool m_opened_yyin;
};

namespace yy {
std::basic_ostream<char>& operator<<(
  std::basic_ostream<char>& os, Parser::token_type t);
}

namespace std {
std::basic_ostream<char>& operator<<(
  std::basic_ostream<char>& os, const std::vector<Parser::token_type>& tokens);
}
