#pragma once
#include "declutils.h"
#include "gensrc/genparser.hpp"

#include <iostream>
#include <vector>

/** Wraps the generated parser. That includes the API intended for the scanner /
tokenstream and the API intended for the driver.

\internal The class yy::GenParser is generated by Bison. The author of
Parser did not see a way to configure Bison such that the features provided by
Parser are directly provided by yy::Parser.

Note that there's also ParserExt which extends the private implementation
details of the generated parser. */
class Parser final : public yy::GenParser {
public:
  Parser(TokenStream& tokenStream_yyarg, Driver& driver_yyarg,
    ParserExt& parserExt_yyarg, std::unique_ptr<AstNode>& astRoot_yyarg)
    : yy::GenParser{
        tokenStream_yyarg, driver_yyarg, parserExt_yyarg, astRoot_yyarg} {}

  enum TokenClass {
    TKStarter,
    TKSeparator,
    TKDelimiter,
    TKComponentOrAmbigous,
    TKNewline,
  };
  static void initTokenAttrs();

  static const char* tokenName(Parser::token_type t);
  static TokenClass tokenClass(Parser::token_type t);

  template<typename SemanticValueType>
  static Parser::symbol_type makeTokenT(Parser::token_type tt);
  static Parser::symbol_type makeToken(Parser::token_type tt);

private:
  NEITHER_COPY_NOR_MOVEABLE(Parser);

  enum SemanticValueType {
    SVTInvalid,
    SVTVoid,
    SVTFundamentalType,
    SVTString,
    SVTNumberToken
  };

  struct TokenTypeAttr {
    TokenTypeAttr(const char* name, SemanticValueType svt, TokenClass tc);
    TokenTypeAttr();
    const char* m_name;
    SemanticValueType m_semanticValueType;
    TokenClass m_tokenClass;
  };

  /** Redundant copy information allready stored in GenParser.

  m_TokenAttrs[].m_name is redundant to GenParser::yytname_. The author did
  not knew how to access the private member GenParser::yytname_ to be able to
  print tokens. A redundant copy seemed the best among all the bad solutions
  since the tokens do not change that often

  mapping Parser::token_type -> semantic data type is redundant to Bison's
  %token declarations which define the data type of sematic values. Thus
  also redundant to various fragments in the generated files parser.hpp /
  parser.cpp. The author did not see any possibility to make use of
  anything within parser.hpp / parser.cpp. */
  static std::vector<TokenTypeAttr> m_TokenAttrs;
  static std::vector<char> m_OneCharTokenNames;
};

namespace yy {
std::basic_ostream<char>& operator<<(
  std::basic_ostream<char>& os, Parser::token_type t);
}

namespace std {
std::basic_ostream<char>& operator<<(
  std::basic_ostream<char>& os, const std::vector<Parser::token_type>& tokens);
}
