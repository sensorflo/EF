:encoding: UTF-8
// The markup language of this document is AsciiDoc

include::../README[]

== Designing EF


[[motivation_details]]
=== Motivation for EF revisited 

See also <<motivation_abstract>>. Thoughts about what EF could provide overall
what no other current language can provide overall.

Hard real-time / deterministic;; This is important for many embedded systems.
Any programming language with an obligatory garbage collector most probably
won't be suitable for hard real-time.  I am unsure about exceptions: there are
zero overhead implementations, 

Concurrency support;; ...

Low power consumption;; This is important e.g. for portable devices running on
battery or big server farms.  Interpreted languages in contrast to natively
compiled languages almost certainly use more power when the program is
executed (more machine instructions executed and / or more memory
consumption).  Most modern programming languages are interpreted.  However JIT
for many of them is already common, is it?  And in that case, what can be said
about the power consumption?  After all there is still a VM, a typically big
run-time, typically huge memory consumption.

Safety nets;; By default bound checks, contracts, invariants, static type
system, making it hard to accidentally drop errors.  For the user it should be
easy to the correct thing and hard to do the wrong thing.  However EF does not
try to take safety to the extreme.  Ease of use is also important.  Also EF
does not patronize the user; when the user really wants it, he can do
everything he can do it C.  I don't know where ADA and/or Ravenscar profile
fit in here.  I think they are closer to high safety than to ease of use for
my taste.  C&plus;&plus; 'if' correctly used also has adequate safety nets,
but it is too easy to accidentally do the wrong thing and IMHO too hard to the
right thing.

As direct access to HW resources as C;; Despite the default way of programming
in EF is `safe', if the user really wants he can get as raw access to HW
resources as in C.  He has to be explicit though, so it doesn't happen by
mistake and is easy recognizable.

Performance at run-time;; Help compiler in being able to do optimizations at
run-time.  E.g. with pure functions, knowing that pointers are not
aliases, etc.  Most notably try to allow for global optimizations, including
inter module.  Allow for compile-time evaluation of many constructs.  Allow
for optional optimizations at run-time.

Easy consistent syntax;; Simple things are easy to learn, easy to maintain,
it's unlikely to make accidental mistakes, it's more fun when things work as
intended and when you don't feel dumb.  C&plus;&plus; is an awful complex
language once you start to dive into the language's details.

Small run-time;; In order the binary also fits on a small embedded system.
However does not take that to really tiny (for 2014 standards) embedded
systems.  C is a good programming language for tiny programs.  Having safety
nets and abstractions starts to really pay off when programs get larger.
Anything interpreted is probably to large since the interpreter also needs
space.

Features;; OO, functional programming (includes first-class functions),
generic programming, meta programming, collections (lists, maps aka hash
tables etc) and slices thereof, regular expressions.

Notable things what is 'not' part of the motivation of EF: specially targeted
for safety-critical applications.  That allows for more freedom in what the
programmer can do and how he can do it.  I think when the language is too
pedantic and patronizing, it is not so much fun anymore using the language.


=== Competing programming languages

==== C
Way too few safety nets.  Way too few of the conveniences other classic and
modern programming languages provide.


==== C&plus;&plus; (including newer versions)

Way to complicated syntax and rules, mostly due to it's C legacy.  It's
quicker and arguably more convenient to do the `unsafe' C thing than to do the
`safe' modern C&plus;&plus; thing.  E.g. make use of STL collections with
bound checks or make use of smart pointers.  C&plus;&plus;11 added support for
concurrency.  Since that's via the STL that is too much an add-on as built-in
into the language as it is the case with Ada.


==== Ada (including newer versions)

I can't judge Ada since I don't know it.  The first impression is that it
offers much of what EF wants and what is objectively measurable.  My
subjective first impression is that it feels a bit verbose.  Voices on the
internet say it's OO feels attached rather than properly built-in.


==== Real-Time Java 

I suspect the run-time to be too big for small embedded system.  Since it's
still interpreted, I suspect the power consumption to be still higher compared
to say C&plus;&plus;1.  Modern compilers / run-times might really have decent
on-average performance -- I'm not convinced yet that this good enough when you
want to be sure certain parts are always (not on average) really fast.  Java
is weak in directly accessing HW resources on a level as C can.


==== Lisp
Is apparently often used in robotics.  It is interpreted and has garbage
collection.  Is thus not suitable for a hard real-time embedded system.


.to-do:
* Read Wikipedia's ``Comparison of Java and C&plus;&plus;''
* http://www.embedded.com/design/prototyping-and-development/4024892/Ada-and-Java-real-time-advantages
* http://www.adacore.com/uploads/technical-papers/concurrency-comparison.pdf
* Book: Real-Time Systems and Programming Languages, look for newest edition
* Google for ``Chris Lattner’s theory of compiler design''


=== Guidelines in designing EF

* I like the http://en.wikipedia.org/wiki/Unix_philosophy[Unix philosophy].
  When can these guidelines in designing EF learn from them?
* Prefer mnemonic (even when only one letter) letters/words over punctuation.
* Provide the programmer with tools to directly express what he wants to
  accomplish.
* Easy grammar.  Most of all easy for humans to understand details
  ('complicated' grammars might often be intuitive for humans in most cases
  but not in a few corner cases or where the author of code ``abused' the
  rules).  That also makes it easier to write tools/IDEs.  Common scanner and
  parser generator tools such as lex and yacc should be able to handle the
  grammar of EF.
* No redundancy.  I don't want to be forced to write things twice.  Work with
  identifiers to refer to already said things.
* As in C&plus;&plus;, don't pay what you don't need.
* As in many modern languages, abstractions and checks at compile time and
  run-time shall make programmer's life easier with no or very little overhead
  compared to C.  That is, the default way and the most convenient way to
  program in EF is that way.  You still can use the raw features which C
  provides, but you have to explicitly say so.
  ** RTTI costs, mainly footprint size, which might be a problem in an
     embedded system.  As in C&plus;&plus;, allow to turn it off - but then we
     also loose exceptions?  See
     http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment.
* Trade safety (likeliness to write correct programs) for compile time.  The
  machine has to think, not the human programmer.  Compile time (almost) only
  helps the programmer, but the programmer benefits probably more if he spends
  less time searching bugs / compile/linker problems.
 ** No context sensitive operators/keywords.
 ** With a compile switch disallow the potentially dangerous `from the world
    C' constructs which the verifier can not verify to be correct.
* Trade faster run-time for longer compile-time.  The program is more often
  run than compiled.  Even while developing - why compiling a translation unit
  if you don't let the code in it run?  (OK due to a changed import it might
  has to get recompiled).
* Make it easy to write correct and run-time efficient code, make it and hard
  to write incorrect code, make it obvious when run-time efficiency has more
  than a near zero overhead compared to the C equivalent construct.
 ** Full control as in a C program is still possible, however at the cost of
    less short & nice syntax.  That is intentionally, it should be explicitly
    visible that on purpose for some reason the potentially dangerous C style
    has been used.  But don't go as far as making low level code too bulky,
    because then nobody will want to write a whole file in that manner.
 ** Concerning run-time overhead compared to the equivalent C construct: Does
    it make sense to have 3 levels: 1) guaranteed to have zero overhead 2)
    near zero overhead, around 1-3 machine instructions 3) More.  It does not
    mean that every construct shall have those three in parallel, it only
    means it should easily be recognizable / memorable into which level a
    construct falls.
* However, the more easy a language / library it makes that it is hard to make
  errors, the more likely it is that this is at the cost of run-time
  efficiency.  I'm thinking about the right (smart) pointer / reference /
  collection to use.  What can EF do that it is easy to do the correct _and_
  run-time efficient thing?
* KISS.  Only few people are interested in delving into language details.
  Most just want to use the language.  That is especially true in the
  industry, and I want EF to be applicable for embedded systems.
* To be successful on embedded, the produced binary must not contain much
  overhead (size)
* One thing has only one responsibility
 ** Applies also to keywords / operators in EF
  *** Avoid the case that one keyword affects multiple different things at the
      same time, especially regarding storage, lifetime, scope, linkage.
  *** Context insensitive, a keyword/operator has always the same meaning in
      any context
  *** Choose linkage, lifetime, storage, scope, alignment etc with dedicated
      keywords.
 ** EF shall help that the constructs the programmer creates adhere to this
    principle
 ** Const local objects -- apart from loop variables, collecting/summing up
    variables, it's hard that one object with given name really can reasonably
    contain different values at different times.
* For the cases where there exists facts and data that a given abstraction
  (say e.g.  smart pointers) helps the programmer to write less bugs at little
  near zero or even zero run-time costs, people still might object using these
  abstractions.  Because they don't know the facts/data, or don't believe
  them, or they really have a special case where the `near zero' overhead
  becomes a noticeable overhead.  Especially in the embedded hard real-time
  world people want full control.  So EF has to provide full control if it
  wants to have a chance to be accepted.
 ** provide compile switches for style guides.  Then project's guidelines can
    choose whether they want to allow C features for ultimate control or
    disallow them for more safety at nearly zero run-time costs.
* inspiring:
  ** Targeted toward embedded system.  C / C&plus;&plus; / Lua / Tcl / Ada /
     Ravenscar profile / Hume / embedded C&plus;&plus; / Java Real-Time
  ** OO: C&plus;&plus; / D / Java / C# / Ruby / Python / Eiffel
  ** Functional programming: Lisp, Smalltalk, Scheme, Ruby, Python
  ** Generic programming: C&plus;&plus; / D
  ** F#, OCaml (boasts to be nearly as fast as C)
* Clean code can be reads as English prose.  You read the code from left to
  right and directly get English prose.
* Regarding the field difference run-time evaluation and compile-time
  evaluation, type_expr, type_def, ctconst etc. don't re-invent the wheel.
  Look at how lisp and other language do that.


=== Embedded system constraints

* http://electronics.stackexchange.com/questions/3027/is-c-suitable-for-embedded-systems
* http://www.inf.ed.ac.uk/teaching/courses/es/PDFs/lecture_5.pdf        
* http://741mhz.com/exceptions-performance/
* http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment
* http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.8024&rep=rep1&type=pdf  
* http://forum.dlang.org/thread/unreajijtwafywprqaag@forum.dlang.org?page=2#post-op.wmhetvpwsqugbd:40fbsdx64.lan
* http://programmers.stackexchange.com/questions/84514/why-does-c-dominate-in-the-embedded-software-market
* Book: Real-Time Systems.  Design Principles for Distributed Embedded
  Applications.  Kopetz, Hermann.
* From http://stackoverflow.com/questions/1601893/why-are-c-c-and-lisp-so-prevalent-in-embedded-devices-and-robots
  2/3:
 ** deterministic memory management
 ** access to well-defined bit sizes (still not sure how LISP fits in here)
 ** simple execution environment
 ** entirely functional (natural fit for concurrency) or general purpose
    (flexibility, embedded systems often have special needs)
 ** flat memory model
* From http://www.stroustrup.com/abstraction-and-machine.pdf:
 ** Bit, byte, pointer, and array fiddling should be the last resort rather
    than the first choice.  C&plus;&plus; balances costs with benefits for
    “advanced features”, such as classes, inheritance, templates, free store
    (heap), exceptions, and the standard library.  If you need the
    functionality offered by these facilities, you can rarely (if ever)
    provide better hand- coded alternatives.  The ISO C&plus;&plus; standard
    committee’s technical report on performance [ISO, 2005] is provides data
    and arguments for that proposition.
 ** Exceptions (throw/catch): The time needed to handle an exception depends
    on the distance (measured in function calls) from the throw-point to the
    catch-point and the number of objects needed to be destroyed on the way.
    Without suitable tools that’s very hard to predict, and such tools are not
    available.  Consequently, I can’t recommend exceptions for hard real time;
    doing so is a research problem, which I expect to be solved within the
    decade.  For now, we must use more conventional error-handling strategies
    when hard real time is needed, and restrict the use of exceptions to large
    embedded systems with soft real time requirements.
* to-do: Read The ISO C&plus;&plus; standard committee’s technical report on
  performance [ISO, 2005]:
  http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf
* Is it really the case that for many embedded systems only a C compiler is
  available, which would mean that at least EF compiler is needed which's
  output is C?  However that would be horrible to debug, would it?  And isn't
  it easy enough to write a back end for GCC or LLVM for someone wanting to
  write EF for his embedded system where he currently only has some C
  compiler?
* Mind that most of the time only a small part of the embedded system is under
  hard real-time constraints.  What benefit can we draw from that?
  ** Turn off exceptions completely for all or only a subset
  ** If it is the case that one exception implementation is on average better
     than another, but the second is better for real-time because of better
     predictability, than maybe let the user choose.
* Are exceptions compatible with the idea that EF should be applicable in a
  real-time environment ?
 ** See above, Stroustrup's opinion.
 ** http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment
 **  http://741mhz.com/exceptions-performance/
 ** Also when I use return codes it's no difference in difficulty to
    measure/guess/prove how long a call takes in the worst case.
* Anyway, even if modern exception implementation would be suitable in an hard
  real-time embedded system, there still might be reluctant people who are in
  charge, so EF maybe still needs a way to turn exceptions off as
  C&plus;&plus; can.
* An embedded system often does have things a normal OS has: files,
  processes/threads?, ... What is the influence on EF's stdlib?


== Meta syntax used in this document

https://github.com/sensorflo/yasmala[Yasmala] is the meta syntax (aka
notation) used in this document to describe the syntax of EF.


== Program structure

In EF everything is composed of expressions, thus a program is just an
expression.  See chapter <<expressions>>.
----------------------------------------------------------------------
program = sa_expr;
----------------------------------------------------------------------


== Identifiers

Similar as in C&plus;&plus;.  Regarding the optional leading sharp sign, see
<<sharp_prefix>>.

----------------------------------------------------------------------
identifier = [\#]'[a-zA-Z_]'[a-zA-Z_0-9]+;
----------------------------------------------------------------------


[[expressions]]
== Expressions

In EF everything is an expression.  There is no such thing as an `statement'
as it is the case in e.g. C, C&plus;&plus; or Java .  Every expression is in
one of these two syntax forms:

* _operator expression_: An unary/binary/n-ary operator as in ++a * b++.  See
  <<operator_expr>>.
* _list expression_: See <<list_expr>>.

----------------------------------------------------------------------
program = expr;
expr = (standalone_expr [\,]{?})+;
standalone_expr = sub_expr;
sub_expr = operator_expr | primary_expr;
operator_expr = sub_expr ('and|'or|...) sub_expr | ...;
primary_expr = list_expr | literal | ID | ...;
list_expr = 
  'while expr#cond \: expr#body \; |
  'var ID \: type_expr \; |
  ...;
----------------------------------------------------------------------

- _stand alone expression_ (aka mini block expression): See <<mb_expr>>.
- _sub expression_: Part of an enclosing expression, can be operand to an
  operator.
- _primary expression_: Leaf of an operator expression tree.

.To-do
- Read http://en.wikipedia.org/wiki/Monad_(functional_programming)
- I want a mostly context free grammar.  That is easier for human brain and
  for compilers.  100% is probably is not possible.  E.g at global scope, an
  arithmetic operator is meaningless.  Then again, maybe we can allow that.
  Such expressions, as initialization of static variables, are executed in
  undefined order at program start-up.  EF doesn't patronize the user.


[[list_expr]]
=== List expression
The following explains the syntax of list expressions (aka `function calls').
They resemble the syntax of a function call in C / Java etc.  However there is
not necessarily a function call at run-time.

------------------------------
func  arg      arg1   arg    arg2  arg     arg3  list
name  list            sepa-        sepa-         close
      open            rator        rator         deli-
                                                 miter
foo    (        a       ,     b     ,       c      )
if              a       :     b    else     c      ;
if     (        a       :     b    else     c      )
if              a       :     b    else     c   end if
[               a       ,     b     ,       c      ]  
------------------------------

The pattern is always: A leading `function name'. Followed by an optional
argument list open delimiter (left parenthesis).  Followed by an argument list
where the elements are separated by separators.  The valid separators are
specific to the specific `function name' (e.g. commas or colons or keywords
such as +elif+ or +else+).  The list expression is closed / delimited by an
delimiter (semicolon or right parenthesis).

----------------------------------------------------------------------
call = fun_name args_open_del naked_arg_list args_close_del;
args_open_del  = [\(];
naked_arg_list = (arg1 separator{-})* 
args_close_del = ['end ...] ( \) | \; );
----------------------------------------------------------------------

The argument list open delimiter and the argument list close delimiter can be
freely mixed from a syntax point of view, also if that looks awkward for
humans.  Both ++if ( a : b ;++ and ++if a : b)++ are syntactically valid.
Such `mismatches' will be caught by built-in configurable style guidelines.

The argument list close delimiter optionally starts with ++end ...++.  The
full list expression looks then e.g. like ++if a : b end if;++ or ++def fun
foo(): int = ... end foo;++. Note that at the very end of the argument list
close delimiter there is still a semicolon or closing parenthesis.  The word
after ++end++ is free from a syntax point of view.  Built-in configurable
style guidelines will enforce that it `matches' the beginning of the list
expression.  What exactly can / must come after the ++end++ keyword is not yet
clear, Ada can deliver ideas.

Note that in the following list expression ++[a, b, c]++, the opening bracket
++[++ is considered the `function name'. The `function' ++[++ creates a
literal list.  Similarly, the `function' ++{++ (e.g. ++{a, b, c}++) creates a
so-called `block'.

General syntax of a list:

----------------------------------------------------------------------
# list
expr_list = (sa_expr \,{?})*; 
# associative list
expr_alist = (sa_expr#key `=> sa_expr#val  \,{?})* 
----------------------------------------------------------------------

Note that a function call as a whole looks like an list expr, but actually is
an <<operator_expr>>. Its rhs is an expression delivering an code object, and
its lhs being an argument list.


**to-do:*

- Depending on the context, the list is interpreted / evaluated-at-run-time
  differently.  Define all possible variants more detailed.  This definition
  must be easily rememberable by humans.
  * Argument list when calling a function
  * Parameter list when declaring a function
  * The sequence of expressions constituting a block (aka body)
  * Expressions involving expressions lists such as e.g. ++[a,b] = [c,d]++
    which is another way of writing ++a=c b=d++. !!! Especially here, when
    should comma be in the sense of a Python tuple and when in the sense of a
    C++ comma!!! Possible answer: its always in the sense of a tuple (aka
    compile time expression list), and the directly enclosing construct
    defines what is done at compile-time and what at runt-time. 
  * ...
- Consider using ++$++ instead ++;++ to end lists, ++;++ for
  lists in a `execute-sequentially-at-run-time' context, ++,++ for  `create
  some form of list data structure'.  Would look more like C&plus;&plus; /
  Java etc, would maybe be a bit less ambiguous, but also would hide a bit more
  that it's all about lists (hmmm, that argument can be pro _and_ contra).
- Define unambiguously (not only technically, but also in the sense of a
  human's guts feeling) to which outer construct commas belong.  I would like
  to make things possible as ++if cond : a , b;++, i.e. ++a, b++ would be the
  2nd argument to the +if+ `function', i.e. there the comma `lives' only
  within the 2nd argument, on the level of ++if++'s argument list.  I also
  would like if separators with same meaning are exchangeable ++if(a,b,c)++ or
  ++if(a : b else c)++ or ++if(a : b , c)++. Obviously the two goals are not
  compatible.

  !!!! if,(...,..) for the comma form if( .... ) and if .... ; for the
  dedicated sep form.  Or inverse if(...) for the comma form and if:(...) for
  the special sep form (exactly like that not possible because
  indistinguishable form special sep form with empty condition. !!!!

- Introduce a term like _form_ (from lisp) denoting the general concept
  which's specialization are a) regular functions (term?) b) `compile time
  functions' like +if+ (term? I think this is what lisp denotes `form').
- Settle for a name.  Currently these are floating around:
 * expression list +expr_list+
 * compile time (expression) list +ct_list+
 * sequence +seq+
 * tuple
 * runtime sequence
 * data list


[[operator_expr]]
=== Operator expressions / operators

These operators correspond to what is found in most programming languages.

----------------------------------------------------------------------
operator_expr = boolean_expr | bit_expr | comparison_expr |
  arithmetic_expr | assignment_expr | other_operator_expr;

arithmetic_expr =
  ('root2 | 'log2 | 'loge | 'log10 | \+ | \-) sub_expr | 
  sub_expr (`+ | `- | `* | `/ | `% | 'pow | 'root | 'logb) sub_expr;

bit_expr = 'bit_not sub_expr |
  sub_expr ('bit_or | `| | 'bit_nor | `~| | 'bit_and | `& | 'bit_nand | `~& |
            'bit_xor | `^ | 'bit_nxor | `~^ |
            'shr | `>> | 'shl | `<< | 'sar | 'sal | 'ror | 'rol ) sub_expr;

## all are short circuit operands, they don't evaluate second operand if
## outcome is determined after evaluation the first operand.  Thus they can
## also be used as flow control operands, e.g. as in Perl "foo() or die()".
boolean_expr = 'not sub_expr | sub_expr boolean_bin_op sub_expr;

boolean_bin_op = 'or | `|| | 'and | `&& | `^^ | 'xor | 'nand | `!&& | 'nor | `!|| ;

comparison_expr = sub_expr (`== | `!= | \< | \> | `<= | `>= ) sub_expr;

assignment_expr = sub_expr (`\= | `+= | `-= | `*= | `/= | `%= | ... ) sub_expr;

other_operator_expr =
  sub_expr `?: sub_expr | ## null coalescing operator
  \( sa_expr \);
----------------------------------------------------------------------

Note that a function call as a whole looks like an <<list_expr>>, but actually
is an operator expr.  Its rhs is an expression delivering an code object, and
its lhs being an argument list.


=== Forced parentheses

In case EF can't get the operator precedence intuitive, then force the usage
of parentheses around certain sub-expressions if and only if the value of the
sub-expression is used.  EF suffers more from this problem, since everything
is an expression, i.e. everything is either an operator or operand.
E.g. the following is understandable, although admittedly not really nice:

----------------------------------------------------------------------
(obj string : s("hello")) + "world"
----------------------------------------------------------------------

However the equivalent expression without parentheses, assuming +++++ has a
higher precedence than ++obj:()++, is truly ugly and hard to understand:

----------------------------------------------------------------------
obj string : s("hello") + "world"
----------------------------------------------------------------------

Similarly it must be ++while ((i=j)) ...++ opposed to ++while (i=j) ...++.


[[temporaries]]
[[mb_expr]]
=== Mini block expression / stand alone expression / temporaries
A _stand alone expression_ (aka _mini block expression_) is comparable with a
statement in C or Java.  The storage duration of temporaries is given by the
enclosing `mini block expression'.  Otherwise there is nothing special about
an stand alone expression.


=== Order of evaluation / side effects
The operands of operators, and the operands (i.e. elements) of list
expressions, appear to be evaluated from left to right.  It is also guaranteed
that every operand of an operator (except the conditional operators &&, ||,
and ? :) or list expression appears to be fully evaluated before any part of
the operation or list expression itself is performed.


=== Run-time and compile-time effects of expressions
Each expression has as part of its properties a compile-time component and a
run-time component.

Declaration expressions have only a compile-time component and no run-time component.

Definition expressions (a definition being a super set of a declaration) has
additionally also a run-time component: initializing the object.

Most other expressions only have a run-time component and no compile-time
component.


[[types]]
== Types


[[type_system]]
=== Type system

Roughly similar to C&plus;&plus;.  However more strongly typed, e.g. in order
to facilitate pointer alias analysis (see <<tools>>).


=== Primitive types / Type classification

Roughly similar to C&plus;&plus;. Note that `primitive' type is not the same
as `built-in' type, see also <<builtin_types>>.

- _Fundamental types_
 * More or less those of C&plus;&plus;

- _Compound types_
 * Raw general pointer
  ** Raw pointer
  ** Raw pointer to member
 * Raw array
 * Function
 * Enumeration
 * Class


[[raw_ptr]]
==== Raw pointer
Comparable to C's pointers.  It's intended that the user nearly always uses
smart pointers and nearly never raw pointers directly.  See also raw_ptr in
<<smart_pointers>>.


[[raw_array]]
==== Raw array
Comparable to C's arrays.  Size must be known at compile time.  It's intended
that the user nearly always uses collections and nearly never raw arrays
directly.  Also allow size 0.


[[variable_sized_raw_array]]
==== Variable sized raw arrays
Variable sized raw arrays are arrays which size is determined at runt time at
construction time, but cannot be changed afterwards.  That is unlike dynamic
arrays (vectors in C&plus;&plus), where the size can be changed anytime during
run-time.

Probably a variable sized raw array is not really distinct primitive type of
its own, but is a composition of other primitive types: E.g. a local variable
sized raw array really is a named local const non-owning raw pointer to an
unnamed raw array owned by the stack.  That view might be important for the
case where we want to make any indirection, i.e. pointer dereferencing,
clearly visible.


[[builtin_types]]
=== Built-in types
Built-in types can be seen as built-in classes; wrappers around primitive
types.  Collections, iterators, 

==== Smart pointers
Are described in <<smart_pointers>>.

==== Enumerations
* User chooses whether enclosing namespace gets the names and/or if they are
  contained in the enumeration namespace
* Each enum is, as everything, an object which name as a string can be
  retrieved.


==== Strings & Characters
...


===== Character encoding

Differentiate between 1) the type, e.g. unicode_char, which is capable of
holding any code point and 2) the character encoding into a stream of another
type, typically 8bit bytes, e.g. utf-8 or utf-16.


===== Internationalization
...


==== Collections & iterators

...

=== Declaring types / type expressions
----------------------------------------------------------------------
type_def = class_type_def | interface_type_def | enum_type_def |
  union_type_def | alias_type_def;

type_expr =
  [type_qualifier] (fundamental_type | compound_type_expr) |
  \( type_expr \);  ## to change precedence of type expr operators

type_expr_list = (type_expr \,{?})*;

type_qualifier = 
  'const |:  ## ignored for &, &&, raw arrays
  'volatile |: ## ignored for &, &&, raw arrays
  'alignas<expr>;

fundamental_type = ## aka primitive type
  ## arithmetic types
    ## integral types. probably some need to be moved into stdlib
    ['u|'s].(
      'efbyte#*not necessary 8bit*#|'short|'int|'long|'longlong|
      ['f['ast]|'l['east]]'int('8|'16|'32|'64|'128|'258) |
      ['bigint|'intx]) | ## probably needs to be moved into stdlib
    ## floating point types
    'float | 'double | 'longdouble | 
    ## character types. value is code point. maybe move some to lib. would
    ## have to be variable with anyway, no? How does C++ do it?
    'char | 'wchar | 'utf8char | 'utf16char | 'utf32char
  'bool |
  'tnull | ## type of null pointer literal
  'void |
  'noret;

## !!!!to-do/ensure!!!! all the following after the same pattern as above
compound_type_expr =
  generic_reference_type |
  generic_pointer_type |
  array_type |
  enum_type | 
  function_type | 
  class_type | 
  union_type;

## - drop the name reference and use alias?
## - As in C++, probably references are not objects (thus don't have an
##   address), but sometimes still need memory to store where they refer to.
## - is the property of a const ref still needed that it extends lifetime of a
##   temporary? I think this is now unneeded complexity
## - isn't it that rvalue ref is just some kind of smart pointer? The old
##   owner says: I don't need my content anymore, and the rvalue ref says: I
##   take ownership of your content and do with it whatever I want. With
##   classes supporting move semantics the actual data is not really on the
##   stack, its on the heap anyway. Thus a function can new the data directly
##   using some smart ptr.
##   * Mind the swap example
##   * Read http://www.drdobbs.com/cpp/c11-uniqueptr/240002708
generic_reference_type = 
  ## when type_expr is itself a ref, this outer ref is ignored. Warn if
  ## type_expr is directly explicitly an ref
  (\&|'ref) type_expr | 
  ("&&"|'mref) type_expr;

generic_pointer_type =
  ## 'normal' (name??? to distinguish from member pointer) pointer
  ['[sub]]#ptrsubtype (\*|'ptrto) type_expr | 
  ## pointer (built-in) to member type
  ['[sub]]#ptrsubtype (\*|'ptrto) type_expr 'in class_type; 

array_type = 
  ## array type. a=std::array (default), b=built in
  ['[ab]]#arraysubtype \(\[ctconst_expr#n\]|'arrayof ctconst_expr#n) type_expr; 
----------------------------------------------------------------------

An EF type expression can be read from left to right and the spoken words
correspond exactly to what it technically is.

.Notes
* For simplicity a type name is always a single identifier, e.g. no ``unsigned
  long long''.
* Is it possible that nearly anything by default is signed? Less problems with
  conflicting types.  However some applications really want that MSB.  The std
  library probably cannot have a size() which returns a signed number. 

.To-do
* Add more floating point types, there apparently is also 16bit, 80bit, two
  128bit (112 and 64 mantissa)
* Consider allowing any number of bits for integers.
* Consider user providing means to choose between packed arrays and naturally
  aligned array members?
* Does it really make sense that a type defines its own alignment; that's 1)
  in addition to the declaration of an object 2) the fully expanded type, i.e.
  the resulting type expression, could contain multiple alignas, and EF would
  need to establish rules what the final alignment is.


=== Type aliases

----------------------------------------------------------------------
## At compile-time defines an alias for the given type_expr. At run-time does
## nothing.
type_alias_decl =
  ('newtype|'typealias) identifier | ## incomplete type
  ('newtype|'typealias) identifier type_expr;
----------------------------------------------------------------------

* ++typealias++: Declares an identifier which is an alias for type_expr, but
  is not a distinct type.
* ++newtype++: Declares an identifier which is a new distinct type.

.To-do:
* Provide ability to define aliases, macros for type_expr, e.g. ++defxx
  ptr_to_array *[]++


=== Type information

When everything is an object, than a type object would have these methods

* +id+
* +name+
 ** For template arguments choose whether template name is meant (e.g. T) or
    the passed type (e.g. myclass)
 ** Same analogous question for typedefs: 
* +sizeof+ is often ctconst, but sometimes (e.g. dynarrays as in C) also only
  known at run-time


=== RTTI

- Classes provide a list of their members as std::tuple.  That way e.g. one
  could implement an reliable (though inefficient) operator= or operator==.
  (Naturally EF already provides those operators)


=== Implicit Conversions

Much less implicit conversions than C&plus;&plus;.  No narrowing implicit
conversions.  Maybe apply the principle `explicit is better than implicit'.
After all, EF also tries to result in more maintainable SW.  And always trying
to be clever and short by using a lot of implicit stuff makes it hard
maintain.  Also mind that most people are not interested in studying the
language in depth.  Apply the principle of `make it easy to be used correctly
and hard to be used incorrectly'.  Maybe once again make it a compiler switch
whether e.g. the 0 equivalent is bool false.  Then normally those implicit
conversions are turned off and those hackers really wanting them can turn them
on (and then there is also no reason against using EF).

=== Explicit Conversions

...

=== Misc

Maybe among other ways, provide a format function like shells or Perl offer
it: embed variables directly into the string, prepended with +$+, optionally
curly braces around the identifier.  Look up the ways Perl and Python offer.


[[code_chunks]]
== Code chunks / General Functions

`Code chunk' is a the most generic term standing for all types of function
like things.  What is a better term?  Maybe `general function'?

A procedure does not return any value, while a function does.

=== Properties

Some ideas: 

- <<pure>>
- `const' in the sense of a C&plus;&plus; const method
- constexpr as in C&plus;&plus;11
- final in the sense of a Java final method
- re-entrant
- thread safe
- (pure) virtual


=== (Named) Methods

For now same as functions (regarding the definition), just defined within a
class.  Maybe use keyword +meth+ instead of +fun+.  That also makes
documentation more easy.  I.e. terms used in documentation correspond more to
terms used in code / in the syntax of the language.

- Virtual is default
- Keyword for overwrite, so we have to be explicit in our intend to avoid the
  case to accidentally introduce a new method.  Or the other way round, a
  keyword for introducing a new method.
- Keyword for non-virtual (since virtual is the default)
- No final keyword to prevent overwriting methods or deriving classes.  Only?
  usable in security related areas, and those should achieve their goals by
  other means.  Final is bad for unit testing.  It's bad from the point of
  view that the author of class A shall not dictate others how to use it.


=== (Named) Functions

----------------------------------------------------------------------
##                sep                   sep       sep
## general:  fun  :  args_tuple         ,  rettype = body ; 
## usual:    fun  (  arg1, arg2         )  rettype = body ;

## At compile-time defines an function object.  At run-time does nothing.
fun_obj_def = 'fun identifier#name fun_type_expr block_expr;
fun_type_expr = fun_signature | identifier#*function type*#;
fun_signature =
  [\( named_type_list \)] ## defaults to ()
  [`: named_type_list ] ## return type, defaults to auto_t, typically only one element in the list
                        ## Only allowed to omit if guide compile switch is set
  ['throws \( type_expr_list \)] 
  ['is funcqualifiers];

named_type_list = (named_type \,{?})*; 
## To-do:
## - "[\= ctconst_expr]" is not really part of a general type list, it is
##   only available in a function signature.
## - make it really analogous/'compatible' to how objects are defined in
##   general.  What this makes special though is that were in a `(argument)
##   object declaration context', i.e. declaration of objects is the only
##   reasonable thing to do, thus we can omit things which are otherwise
##   needed to declare an object.
named_type = ('val | 'var) [identifier#name [\= ctconst_expr] \:] type_expr;

## To-do: What exactly is the returned type? Something like named_type_list
fun_call_expr = fun_obj_expr \( expr_list \);
----------------------------------------------------------------------

For example:
----------------------------------------------------------------------
fun factorial(int:i) -> int {
  if (i<=1) { 1 }
  else { i * factorial(i-1) }
}
----------------------------------------------------------------------

.To-do
- Allow that definition only uses name already introduced by declaration, so
  we don't have to redundantly state signature again.  That fails for
  overloads, but see function name aliases.
- Allow to add aliases to functions.  Both to other name, ignoring signature,
  and to the complete thing (name+signature).
- A lambda is an anonymous function.  That should be visible in some way from
  the syntax.
- What if i want an anonymous function and define signature via an function
  type name?


=== Overloaded Operators

Support the case that the class can also be the rhs of the other type is
the lhs.  That avoids the need for being forced to define a global operator for
that case which also forces that global operator to be private.

See also D: Auto deduction of all comparison operators after == and any of (<
<= > >=) are given.

See also ``Properties of some standard methods/operators''.


=== Function call

==== Argument passing with key => value pairs
The caller can pass the arguments as ordered list as in most languages.
Additionally each element in such a list can also be a key => value pair, the
key being the name of a parameter which's value is to be set to the value of
the pair.

Notes:

- What is the type of such a key value pair?  How can we differentiate whether
  the caller intends to pass a key value pair as discussed above, or whether
  that pair as a whole is the value to be passed?
- The benefit is that when reading code at caller side, it is more descriptive
  / informative.  However shouldn't it be the task of the IDE to show the
  reader information (type, name, doc) about each parameter of the function
  at hand?
- Parameter names would become half way part of the signature.  If the
  implementation changes a parameter name, some client code might be broken.
- The set of function declarations plus the function definition all had to use
  the same names.  This can be seen as good and as bad.
- What about function pointers?  Can the declaration / definition of a
  function pointer use different parameter names?  After all, the parameter
  names are not really part of the function's signature.
- Also, at least with pedantic name comparison, each caller has to overtake
  the naming style (prefixes, camel case vs underlines, ...) of the method
  implementation.
  * If the comparison rules would leave some controlled leeway, the callers
    could be decoupled from the naming guidelines of the implementation.
  * The caller could provide an internal name and an external name.  Maybe in
    one go where encoded in the name is what is part of prefix/postfix, and
    what is part of the base name
  * But then still, if that base name consists of multiple words, there many
    ways how to exactly `encode' them in an identifier: camel case,
    underlines, ....
  * EF tries anyway to soft enforce a style which is used by everyone.  Here
    it would help again that the implementer side and the client side have the
    same naming styles anyway.


=== Lambdas

An anonymous aka unnamed function.  An unnamed closure which makes no
references to environment.


=== MethLambdas

An unnamed method. 


=== Closures

A closure is any (named or anonymous, does not matter) function which closes
over the environment in which it was defined.  This means that it can access
variables not in its parameter list.  See also
http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda

Can they be templatized?


=== Contracts

See D / Ada.  For all types of code chunks.

Pure virtual methods should also be able to have contracts, no?  That includes
interfaces.

Interfaces should also be able to have invariants, no?


=== Overloading

Consider not supporting overloading in EF.

- Together with implicit conversions and namespaces / modules it gets
  difficult to understand which conversions happen and which overloaded method
  is called at the end.  Both for humans and for compilers.
- I like overloading and use it not seldom.  Still it is only convenience, it
  only saves me from having to invent multiple names instead just one name.
  The maintainer also has to know multiple names instead just one, but he has
  (having overloading) also to remember the multiple signatures, so no
  difference for the maintainer.
- On the other side, for constructors we most certainly have overloading
  anyway. 


=== Variadic arguments

Mainly to be compatible to C, to be able to build wrappers around C.  But
shouldn't the wrapper then use a more EF like construct?


=== Properties of some standard methods/operators 

Not only is the code more maintainable since these common operators really do
what humans expect, but also the compiler / analyzer / optimizer ... can
deduce helpful things.

Copy ctor, move ctor, assignment, move assignment have the properties
generally assumed with them.  Const member methods, the copies are equal (see
operator==), .... Thus e.g. a ctor with an initvalue followed by an assignment
can be replaced by a ctor with rhs of assignment as initvalue.

Relation between unary/binary plus/minus, between multiplication and division,
binary operation and assignment and the `corresponding' x= assignment, binary
operators with two distinct types as parameter have 3 methods in
CC&plus;&plus; (member, two global), postfix/prefix increment leave the object
in the same state (i.e. when the return value is not inspected, the compiler
can choose the more efficient).  When a unity object is known, then
&plus;&plus; is equivalent to &plus;&plus;=, same for minus.  That
e.g. helps that ++result = a + b++ could be strength reduced to ++result = a;
result += b++ (the later does not need to create & destroy a temporary).

Can the compiler automatically verify that a user implemented method fulfills
all requirements/rules?  How to explicitly break the rules, if a user really
wants to implement some of these methods specially.  How to enforce standard
types / type qualifiers.  E.g. assignment is a const member methods, expects
an const X& arg, returns an X&.

See also ``Overloaded Operators''.

=== Chaining functions

As in #F with ++|>++ allow to stream output of one function into input of
another function.  Is it possible to have one general solution that also
includes pipes / redirection?  Learn how Windows PowerShell does it.


=== Optimizations

Does it really help if the user has to explicitly state properties such
e.g. pure? After all the compiler can deduce it itself and attach e.g. the
pure property to a function itself internally.  The explicit keyword is
probably only good for humans a) to communicate to a reader that this function
potentially can be used in an efficient manner b) to communicate to the
compiler that it should print an error when the function is not pure
after all.


[[pure]]
==== Pure

See D for pure functions.  In EF, pure can be a property of any code chunk.

Do also a lesser form of `pure' for class member methods: they are as pure
functions but are allowed to read access class members.  When an object is
never modified between such method calls the 2nd call can be omitted by using
the behind-the-scene stored return value of the 1st call.

I think the general version of the above is: when the compiler can detect that
a function call tree does only read from memory that is not modified between
two such calls, then the 2nd call can be ommited by using the behind-the-scene
stored return value of the 1st call.


==== Tail call optimization

...


==== Return value optimization (RVO)

Probably part of the more general copy elision.


== Initialization

Much easier than in C&plus;&plus;.  Only one / a few simple principles.
Either completely orthogonal or simple aliases.


== Comments / Documentation / EFDoc

I plan to change the comment style using # to the style used by
C&plus;&plus;. Then # is free as prefix for names, see <<sharp_prefix>>.  As a
special exception #! at the beginning of a file is (still) treated as a
comment to support the shebang.  The following is the old idea based on #:

----------------------------------------------------------------------
comment = 
  \#(\*+) ...\1\# | ## multi-line
  \# ... \n ;  ## single-line
----------------------------------------------------------------------

The multi-line variant can be nested.  E.g given ++a #* b #* c *# d *# e++,
from b to d inclusive is within the outer comment.  The closing delimiter
needs as many stars as the opening delimiter.  That way sequences like *# can
be included in the comment: `#** in EF the *# ends an comment **#`.

.Notes
- Having # as delimiter allows to use the shebang mechanism.

.To-do
- Institutionalize using Doxygen or Doxygen like markup language.
- See EFDoc why it makes sense to integrate the doc language into the
  compiler.
- Inherited classes, overloaded methods, overwritten methods,
  member-getter-setter, delegate methods: Find a way that only a minimalistic
  comment (one keyword) or none at all has to be written and still have 1)
  good doc output 2) even in code the maintainer sees quickly that the
  identifier is not documented here but at another place.


== Modules
Do it as in D / Java / Python, have modules, opposed to the concept of C /
C&plus;&plus; with header / source files.  Currently this document uses the
terms `library' and `module' interchangeably.


[[exchanging_module_impl]]
=== Exchanging module implementation
Given a library L1 used by another library L2, and a user module MU using at
least L2, and the user wants to provide his own implementation of L1.

First concrete use case: user can provide an implementation of the memory
management sub-module (malloc, free etc) of the EF standard module.  See
<<memory_management>>.

Note: When compiling module A which imports module B, the resulting object
file for module A can be more efficient if the compiler can look at the
implementation of B.  If A was compiled that way, and thus potentially inlined
some methods of B, and module C uses A (and only has A's object file) and B,
then B can't be exchanged.

[[objects]]
== Objects

[[obj_properties]]
=== Object properties

An object, in EF, is a region of storage with the following compile time
properties:

* _type_
* _value_:      
* [_name_]: A name is optional
* _size_: Is implicitly defined by object's type
* _scope_: 
* _linkage_:
* _alignment_:
* _lock wrapper_ Just an first idea.  See also <<concurrency>>.

* _storage duration_: Begins after storage allocation (which is before
  constructor call) and ends just before storage deallocation (which is after
  destructor call).  See also life time.  Members inherit storage duration
  from parent object.
 ** _static_
  *** _system static_: system global, implies shared ownership and implies
      shared access
  *** _process static_: process global, implies shared access
  *** _thread static_: thread private global, implies exclusive access
 ** _automatic_: Informally explained: objects on stack.  That includes
    <<temporaries>> and parameters.
 ** _dynamic_: Informally explained: objects on heap.

* _owner(s)_ / _exclusive/shared ownership_: The owner is responsible for
  freeing the underlying memory resource.  Knowing the owner(s) implicitly
  that defines exclusive / shared ownership: one owner -> exclusive ownership
  / two or more owners -> shared ownership, .
 ** System: 
 ** Process: Implies `shared access by multiple execution threads' (if not,
    why not making it thread local?) 
 ** Thread:
 ** Block/stack: Register is not an owner; its an transparent
    optimization when the optimizer puts an object into an register instead on
    the stack.
  *** Enclosed block on stack:
  *** Enclosed `mini' block on stack: E.g. for temporary objs not assigned to
      observer_ptr.
 ** Owning smart pointer & heap: Only objects on the heap can be owned by
    smart pointers.  Freeing the heap object means passing back ownership of
    the underlying memory region to the memory manager.  So in a way both the
    owning smart pointers and the heap are owner the object.  If the object is
    from a shared heap, then it implies `shared access by multiple execution
    threads'.
 ** Parent object: for member objects
 ** Garbage collector:
 ** User & heap: Only for objects on the heap.  The user must do what normally is the
    job of an owning smart pointer.  See also owner type `owning smart
    pointer'.

* _allowed observer_: Describes the allowed observers of the object.  Each
  owner is also an observer, but there are potentially additionally also
  non-owning observers (being only(?) non-owning pointers).
 ** _exclusive/shared observability_: exclusive observability -> at most one
    observer allowed.  shared observability -> two or more observer allowed.
    The compiler must ensure that the (last remaining) owner does not free an
    object which still has other observers.  See also `current observers'.
 ** __``execution thread(s) having observers''__ / _mutual exclusion required_
    / _time shared_ / _exclusive / shared access_ (accessors being different ``threads of
    execution''): If all the observers are in one execution thread, or if none
    of the observers makes write access, then no mutual exclusion is needed.
    Otherwise the object needs some form of mutual exclusion.  ``execution
    thread'' is meant to be an umbrella term for thread, process,
    ISRs, .... *To-do:* 1) What exactly does `to be in' mean when saying 'an
    observer is in execution thread ...'

An object has additionally the following run time property:

* _life time_: See also storage duration.  From the C&plus;&plus; standard:
  3.8 Object Lifetime: 1/The lifetime of an object is a runtime property of
  the object.  The lifetime of an object of type T begins when: — storage with
  the proper alignment and size for type T is obtained, and — if T is a class
  type with a non-trivial constructor (12.1), the constructor call has
  completed.  The lifetime of an object of type T ends when: — if T is a class
  type with a non-trivial destructor (12.4), the destructor call starts, or —
  the storage which the object occupies is reused or released.

* _current observers_: Determined by compiler at compile time.  The owner can
  (checked by compiler) only free an object if no observer beside the owner
  remains.  (or more specifically, if no observer actually observes / accesses
  the object after the deletion). See also `allowed observers'.


[[obj_decl_def]]
=== Declaration / definition
Type, storage, linkage, alignment can be defined as following:
----------------------------------------------------------------------
obj_def = local_obj_def | global_obj_def | classmember_obj_def | fun_obj_def;

obj_prop_expr = type_expr [storage linkage alignment scope]#*any order*#;
storage = 'static_storage | 'thread_storage | 'auto_storage;
linkage = 'extern | 'intern;
alignment = 'alignas \( (sub_expr#integral|type_expr) \);
scope = 'block_scope | 'full_expr_scope;
----------------------------------------------------------------------

.To-do
* Is alignment part of object definition or of type_expr?


=== Layout

- Don't have C&plus;&plus;'s restriction that each obj must have an unique
  address.  Or just allow for zero sized objects, in particular zero sized
  arrays.  
- +alignof+
- bit fields
- pack as attribute to structs/classes


=== Local objects

A bit simplified, the ++obj++ family of `functions' create a new object,
initialize it with the given initializer, bind the given identifier as name to
it and finally return a reference to the new object.

----------------------------------------------------------------------
## if obj_prop_expr is omitted it defaults to 'auto_t'
## if identifier is omitted, it's an unnamed object
## obj{}
local_obj_def =
  ## intended for simple small (chars for code) initializers; obj_prop_expr is
  ## typically less important and thus at the end
  ('val|'var|'obj)     [identifier#name] initializer                        [\: obj_prop_expr] \; |
  ('val|'var|'obj) td ([identifier#name] initializer \,{?})+ td             [\: obj_prop_expr] \; |
  ('val|'var|'obj) td ([identifier#name]             \,{?})+ td initializer [\: obj_prop_expr] \; |

  ## intended for complex multi-line initializers
  ('vals|'vars|'objs) [identifiers#name] [\: obj_prop_expr] initializers \; |

  ## short form.  Is now an binary operator
  identifier#name ( `:= | `:&= ) sub_expr#initvalue  |
  td (identifier \,{?})* td ( `:= | `:&= ) td (sub_expr \,{?})* td ;

identifiers =  (identifier \,{?})* ## a tuple, to be defined uniformly elsewhere

initializers = (initializer \,{?})* ## a tuple, to be defined uniformly elsewhere
initializer =
  ## constructor call syntax
  \( (expr_list | 'noinit | 'laterctor ) \) |
  ## an alternative syntax to the constructor call with one argument.  "obj
  ## x = 3;" and "obj x(3);" are equivalent.  Also here noinit can be used.
  ## '(sub_expr)'
  \= sub_expr |
  ## omitting the initializer is an alias to the '()' initializer
  ;

td = #* tuple delimiter *# ;
----------------------------------------------------------------------

.Example
----------------------------------------------------------------------
obj a = 3, b(3), c;

fun get(int, &double);
get( 0, obj double f ); 

obj string { a, b } = get2strings();
----------------------------------------------------------------------


==== Initialization

===== Uninitialized / not-yet-constructed objects
EF supports the ability to not initialize a variable with the +noinit+ keyword
/ initializer, most probably for run-time efficiency, as it is possible in C.
However in EF the programmer has to be explicit.  Such an object is considered
to be constructed and usable. 

EF also supports saying (with the +laterctor+ keyword / initializer) that
everything as normal is done, just the constructor is not yet called.  The
object is not allowed to be accessed.  Provably, so rules need to be stated
what the code up-to the actual ctor call is allowed to look like.


**To-do:** Is +noinit+ really needed after there is +laterctor+?


===== Guaranteeing initialization
Sometimes one desires to initialize a variable with something other than the
return value of an expression.  E.g. via an out parameter of a function
(i.e. passing the new not yet initialized object and let it be initialized by
the function).  Or each clause in a conditional flow control expression
wants to define somewhere the initializer.

Keywords that promise that a function will init an outparameter -- write to it
at least once before reading from it.

Keywords in a flow control expression that promise that a given object will be
initialized -- written to it at least once before reading from it.  That also
would be a use case for the the example that a flow control expression as a
whole returns already the desired initializer, but the when its a long
multiline flow control expression, then ++var i : int = if ....;;++ may look
awkward (on the other side that's just a matter of taste, which is also a
matter of being used to such constructs).

**To-do:** In case of the +laterinit+ initializer.  The flow control
expression's clauses can not call assignment but must call the ctor?  Not if
the class promises that (ctor with laterinit/noinit followed by assignment)
and (normal ctor with initvalue) are equivalent.  Or the rules of EF just say
that the assignment really calls the ctor.  Or there is a syntax to just call
the ctor for an object -- without allocating the storage, since that already
has been done.

**Mind:** Let the computer automatically deduce non-initialized variables where
possible.  Do not force to user to state things the compiler can deduce
itself -- except where it helps to communicate intend.


==== Associated block
Make it possible that all clauses of a flow control expression can introduce
an object which is associated to an outer block.

Give the user the possibility to choose the associated block also for
variables defined in conditions of a flow control expressions.  For example
a) only the condition b) additionally also one clause associated to the
condition c) additionally all following condition-clause pairs of the same
flow control expression d) the block associated to the object is the outer
block of the flow control expression.


==== Scope and lifetime
The lifetime always at the end of the object's associated block.  


==== To-do
* Define where _exactly_ lifetime and scope begin.  In particular with
  collection initializers: Can one element refer to another one? Does that
  depend on whether the referee was already initialized itself or can you get
  a reference/pointer to a not yet constructed element (that would probably be
  nice to conveniently construct trees).  Can you refer to the collections
  size of the initializer? That also could be useful.
* Try to get rid of : or of obj keyword.  Only having : would be a bit closer
  to the idea that in EF there are only expressions, i.e. only operators.  It
  would also be shorter.
* Try to have the identifier on the lhs and the obj_prop_expr on the lhs.
  Would be closer to the way other declarations and definitions are done
  in EF.  Also I feel the identifier more important as the type -- the type is
  mostly for the compiler for the static type system; in other languages there
  is no type information at all.  This way the identifiers would also be
  aligned, e.g. in class definition.
* Make local objects const by default.  I.e. the +const+ qualifier is
  implicitly prepended to the obj_prop_expr.  Naturally non-const local
  objects must be possible.  It's just that const objects should be the norm
  and to achieve that they should have the easier nicer syntax.  Reasoning:
 ** One thing should only have one responsibility
 ** Is in favor of functional programming where variables are tried to be
    avoided.
* allow to explicitly shadow a name declared in the same scope and/or to pop
  the latest automatic variable from the stack.
* Concerning objects declared in the condition of a flow control expression:
  let the user choose whether he want's the scope to be limited to the
  enclosing block (default, would be one single consistent rule), or whether
  the scope ends at the end of the flow control expression.  Specially with
  the for loop, the iterator variable sometimes is wanted to vanish after the
  loop, sometimes to vanish not until the end of the enclosing loop.  Or
  extend the concept to scope the variable to the enclosing full expression.


[[variable_sized_obj]]
=== Variable sized object
If variable sized raw arrays are allowed as members, then the whole object
becomes variable sized.

An raw array of variable sized objects is not possible.  Thus probably the
object size is like a template argument.  But its not really another type
-- thus that apparently calls for a new type concept: each template argument
has as attribute, whether it contributes to defining distinct type or not.
See <<templates>>.


=== Non local objects
Actually don't differentiate, do it always the same way.  EF tries to have to
have context free grammar (do i use the term correctly?).  So to define global
static objects, we have to say storage type static.  C&plus;&plus; does it
also this way.  The initializer are expressions to be evaluated the same way
as non - ctconst expressions in global scope: in undetermined order at program
start-up.

Similar for member obj of classes.  The syntax is the same as for all obj
definitions.  It's only that the initializer is executed upon construction of
the class' object.

Static class obj are virtually the same as global static obj.  It's just that
the scope is different.

== Structs

Does it help if a struct is nearly the same thing as it is in C?  No methods
no nothing?  Only public members.

Easy initialization, readable.  E.g. similar to Python, caller can provide
something like a map identifier->value, this way he has not to remember the
order.  And the names of the members he has to know anyway.


== OO: Classes / Interfaces

+class_def+ and +interface_def+ are both +type_expr+.
----------------------------------------------------------------------
## At compile-time define a new class type. At run-time does nothing.
class_type_def = 'class identifier#name [\: base_class_list] \{ classimpl \};
inteface_type_def = 'interface identifier#name [\: interface_list] \{ classimpl \};
base_class_list = identifier#superclass [\, interface_list] | interface_list;
interface_list = (identifier#interface \,{?})*;
----------------------------------------------------------------------


=== Inheritance / Super class / Interfaces

Only single inheritance, no multiple inheritance, but implementing of an
arbitrary amount of interfaces.


=== Constructor

The name is +this+ or +ctor+ (ctor and dtor would be very close) or
+constructor+.  Don't use the class' name as C&plus;&plus; does because that
is redundant.

Allow to delete the auto generated ++(noinit)++ constructor:
++constructor(noinit) = delete++

How to call the ctor explicitly?  E.g. for already allocated but not yet
constructed objects.  E.g. due to use of some `non-standard' +new+ construct,
or due to the +laterctor+ initializer.


=== Destructor

The name is ~this or dtor or destructor.  See also ctor


=== Initializer

What is D's init?  Why not just use default ctor


=== Friend

Unlike D, keep +friend+.  I don't like D's solution that within a module there
is no private anymore.  In my eyes private also protects myself / the
maintainers from making mistakes in one single module.  E.g. sometimes
redundancy sadly is needed, and then I want to encapsulate that redundancy in
an very small area, i.e. a very small helper class.


=== Methods / Operators

See chapter <<code_chunks>>.


=== Members / Properties

- See D.  However EF lets you default implement properties.
- In the declaration of a member, one can state whether and what
  gutters/setters are (auto) generated [mind the different access].  The
  implementation is automatic or user given.


=== Invariants

See D


=== Deletion of ctor, dtor, assignment

Instead of making those private, which has the disadvantage that for methods
of the same class the compiler doesn't say anything, only the linker, delete
them.  I think C&plus;&plus;11 also has this feature.  For convenience, also
give a short whatever to delete a group for often occurring use-cases

copy ctor and assignment operator for classes not intended to be copied in any
way


=== Packed

...


=== Pure OO / OO pureness

Also built-in types, but without sacrificing being as close to HW as C.
normal objects, functions, modules, ...

Does it help when there is a common base class as in Java?


== Control flow

----------------------------------------------------------------------
flow_control_expr = conditional_expr | loop_expr | jump_expr | 
  other_control_flow_expr;

conditional_expr = ifchain_expr | givenchain_expr | jumptable_expr |
  'unless [\(] sa_expr (\,|'do) block_expr (\)|'end);

ifchain_expr = '
  'if [\(] sa_expr (\,|'then) sa_expr
  ((\,|'elif) sa_expr (\,|'then) sa_expr)*
  ## if ommited defaults to "else {nop;}", i.e. type void 
  ['else sa_expr]
  (\)|'end);

givenchain_expr =
  ## the optional 2nd expression is a predicate function object which defaults
  ## to test for equality.
  'given \( expr_list#*one or two*# \) 
  ('when \( expr_list#*at least one*# \) block_expr_opt_falltrough)* 
  ['else block_expr]

jumptable_expr =
  'jumptable \( sa_expr \) 
  ('when \( expr_list#*at least one*# \) block_expr_opt_falltrough)* 
  ['else block_expr]  

loop_expr =
  ## to-do 
  ## - like in python something ala "foreach ( key,val in mymap )" 
  ## - like in ?? a nested loop in one written loop "multiforeach ( i,j in matrixindicies )"
  ##   However that gets difficult with jumps (break,continue,...). To which loop do they refer?
  ##   Probably a feature with dimishing returns.
  ## - See function definition for how to declare variables in a `object
  ##   declaration context'
  'foreach \( (sa_expr#obj_decl_context 'in collection_expr )+ \) block_expr |
  'for \(  expr_list#*<void,bool,void>*# \) block_expr |
  ##['begin sub_expr] 'while sa_expr 'inc sub_expr 'do sub_expr | what does ruby, python,
  ##scala, ... do?
  ('while|'until) [\(] sa_expr (\,|'do) sa_expr (\)|'end) |
  'do [\(] sa_expr ('while|'until) sa_expr (\)|'end);
  ## ????? what was my problem that i wanted a condition at the start AND the
  ## end???
## alternatively: 
## integralexpr.times closureexpr

## jumps. The result type of control flow jump operands is typically
## noret. See also labelled_sa_expr.
## to-do: as in Perl, jump to specific loops. Also relative numbers to
## identify nested enclosing loop
jump_expr = 
  'ret sub_expr | ## returns from enclosing code chunk
  ('goto | 'continue | 'redo | 'break) [label_expr] |
  ## defines the enclosing/referred loop expression's value
  'breakwith sub_expr; 

other_control_flow_expr = 
  ## to-do: what is the metatype and type of this expressions?
  'label identifier;
----------------------------------------------------------------------

.Notes
* Short circuit operators such as +or+ or +and+ are also kind of flow control.

.To-do
* As for block_expr, make it a compile time switch whether parentheses are
  enforced for the conditional part of the flow control expressions.


=== Interact with other programs

However mind that not on all platforms you can `execute a program by stating
its path'.  On many embedded systems there is no file system.  Maybe make the
pipes / redirections a more abstract level: something similar to C&plus;&plus;
streams.  Just an easy syntax to connect streams to each other.


=== Redirection / Pipes

Make it easy to interact with other programs using pipes and redirection, like
shell scripts do it.  See also chapter "chaining functions". 


== Ranges

...


== Slices

As in Python/Ruby, easily transform a collection to another collection, or
interpret a collection as another collection.


[[resource_management]]
== Resource management: RAII & GC side by side

Basic idea is to do resource management via RAII as in C&plus;&plus;.  EF
tries to have cheap destructor `calls' by trying to avoid them all-together.
Optionally, simultaneously, also garbage collection is provided for heap
memory.


*to-do*:

* How to prevent that non-returning methods leave no resource leaks behind,
  since destructors of locals are not called.

[[cheap_destructors]]
=== Destructors & how to try to make them cheap

- Lazy destructors (or resource freeing in general) for objects on heap by
  default (that includes `dtors' of smart pointers).  Normal constructors only
  for RAII classes where the resource really must be freed upon destruction of
  the host object.  Customizeable by providing implementations of the
  primitive functions which replace the default implementations
  (++push(__ctor_addr__)++). As in a garbage collector there will be `cleanup'
  rounds.  An _ordered_(!) set of `root' ctors has to be called, which then
  potentially call a tree of further ctors.  A round's run-time can be reduced
  e.g. by partial `collection': stop calling ctors somewhere in the middle.
  * Besides ctor, also e.g. assignment (e.g. to unique ptr) frees the current
    resource owned by the unique smart pointer.
  * Give the user the control whether he wants to do the resource freeing lazy
    or greedy.  The default is that the compiler is allowed to choose what it
    sees fit.
  * +delete+ (or +free+) operator (in lazy and greedy variant) as more
    expressive variant to the equivalent ++= null++.

- Nonexistent destructor: Classes not owning resources, and only having
  objects of such classes as members, need no destructor at all.  Thus no
  destructor needs to be called.  *to-do:* How to arrange that mostly
  non-owning smart pointers can be used, and only seldom owning
  smart-pointers?  Probably it helps if variable sized objects (i.e. most
  probably arrays) are allowed at least on stack, but also as members.

- Try to reduce each destructor to a list addresses of heap objects which need to
  be freed (in any order, without any further ctor code) in one go.  I.e. try
  that the only code the body of a destructor executes is adding a set of
  addresses to the global to-be-freed list.  No dtors of member objects; that
  already has been `inlined' in the list previously talked about.
  * `lazy free' on most occasions, e.g. internally in owning smart pointers, an
    object on the heap is `freed' by just pushing it's address on the
    to-be-freed stack.  Also null can be pushed for simplicity at caller side
    (there is a huge amount of call sides, but only one (or very few) sides
    where the to-be-freed stack is walked through to actually free the
    objects.  *to-do*: Apparently the kernel can automatically grow the stack.
    Can I use a similar feature for the stack of to-be-freed addresses?
  * is it possible to reduce a ctor call to simply pushing a list of heap
    address also in the case of e.g. a linked list where the list objects has a
    smart pointer owning the head node, and each node has a smart pointer
    owning the next node?

- Allocation on stack instead heap, the return type being an non-owning
  pointer.  What can I do such that allocation is transparent, i.e. caller
  does not know whether it allocates on stack or heap?  E.g. consider a
  `normal' local object on the heap which is referenced only by that single
  `normal' local identifier (possibly additionally read only references). When
  it internally wants to allocate objects and wants to be the unique owner of
  them, they can be created on the stack.  The parent object would then not be
  really the owner, and it's dtor could be empty.
  * Will result in a `new'(?) way of stack frames.  After a call, the stack
    will still contain the newly allocated objects within the call.
  * The corresponding free call to such an allocate call will not do anything,
    since the owner is not the caller but the stack.

- When considering costs: Also a `perfect' C program has to pay for things, it
  also has to call malloc/free, do error checking by comparing return values
  and depending on the result do a branch.  So a `perfect' EF program does not
  pay for anything at run time that not absolutely has to be done in any case
  anyway.

[[memory_management]]
== Memory management
See also <<resource_management>>.

Support custom memory management primitives, i.e. user shall be able to
provide its own version of new (aka malloc), delete etc.  The current idea is
that the memory management sub-module of the EF standard module can be
implemented by the user.  See <<exchanging_module_impl>>

Built-in smart-pointer implementation shall be decoupled from memory
management primitives (new (aka malloc), delete, ...).

Make allocation on heap and stack such that optimizers have some leeway to
choose whether in reality it is on stack or on heap.  Probably it'll be
somewhat like: have one form to define allocation of a new object in a syntax
similar to C.  To define an object to be allocated somewhere, create a
(built-in) smart pointer with built-in keywords/syntax, e.g. similar to
C&plus;&plus; ++make_unique++, just hopefully shorter.

Mind concurrency.  Consider having malloc/free in two versions: once for heap
objects owned by only one thread, and once for shared heap objects.  In
anyway, the memory management primitives must be reentrant (also the one
thread private heap malloc method might be called simultaneously from different
threads).

Allow that each thread has it's own private heap.  Memory allocation
primitives on the thread private heap don't need mutual exclusion protection.
Naturally there is also the `traditional' heap which is shared among threads.
Modifying the shared heap requires mutual exclusion which naturally has some
non-zero costs.  The intention is to use the shared heap only for objects
which need shared ownership.  If you only need shared access to an object (but
have an exclusive ownership), a thread private heap also works. 


*to-do*:

* Find out more about batch malloc & free.  Would it help if EF would try to
  favor batch free over a loop with normal frees.
* Read http://en.wikipedia.org/wiki/Manual_memory_management and follow the
  links at the bottom.
* Since EF can somewhat control where pointers point to, it might sometimes be
  possible to move an object in memory.  That can e.g. help within the heap,
  e.g. to release (to the OS, on linux via (s)brk or (anonymous) mmap) `large'
  amounts of free memory which only can be released thanks to moving `a few'
  objects within it.  In a more general sense: the heap manager can fight
  defragmentation better if it can move objects.

=== Layout

- Don't have C&plus;&plus;'s restriction that each obj must have an unique
  address.  Or just allow for zero sized objects, in particular zero sized
  arrays.  
- +alignof+
- bit fields
- pack as attribute to structs/classes



[[smart_pointers]]
== Built-in (smart) pointers

Classifications / abstract base types:

owning pointer::  All of the owning pointers have two variants: 1) to single
  object 2) to array of same size/type objects.  This is needed in order the
  correct delete operator (delete vs delete[]) can be called.  An owning smart
  pointer is responsible to call the destructor of the pointee and then to
  free the underlying memory resource.

  Also each owning pointer has two variants in respect to collaboration with
  garbage collector: _pure owning smart pointers_ are really the owner
  independent of whether GC is turned off or on.  _Regular owning smart
  pointers_ are the owner only if GC is turned off.  If GC is turned on, they
  leave ownership to the GC.

non-owning pointer:: ...

Concrete Types:

(pure_)unique_ptr:: Is the only owner, thus no reference counting needed.  Referred
  obj is of dynamic (non-gc allocated) storage. 
(pure_)shared_ptr:: Shared ownership via reference counting.
address / implicit `pointer':: Owning `constant pointer'.  Pointees are:
  - Objects with storage class static.  Owner is one of system / process / thread.
  - Objects with storage class automatic.  Owned by a block/stack.
  - Member objects.  Owned by parent object.
  - +this+, +super+:
weak_ptr:: Non-owning, but can be promoted to a shared_ptr.
observer_ptr:: Non-owning.  Compiler ensures at compile time that that the
  owner(s) does not delete the object while the observer_ptr points to it.
  Alternative names: leaser_ptr or renter_ptr.  I fear that the word
  `observer' wrongly implies read only access to the pointee.
raw_ptr:: Non-owning.  Primitive type, see <<raw_ptr>>.  Disallowed by
  standard guidelines.  Can point anywhere the other pointers can.  User is
  responsible for mutual exclusion and ownership.  However there still is no
  pointer arithmetic.  That is in order to make pointer alias analysis
  feasible.


General pointer assigning rules:

- If the lifetime of an object o is guaranteed to be longer than the lifetime
  of a non-owning pointer object p, then p can point to o.
- Garbage collector can overtake ownership from owning smart pointers.

Rules to assign an object/pointer to an observer_ptr:

- The observer pointer is a global object, and the referred to object is a
  static object (which will be deleted after to the observer pointer obj),
  or sub-member only following direct or const owning smart pointers.
- The observer pointer is an local object (that includes function
  arguments), and the referred object is either a local object (which is
  owned by stack) or a thread or process static object (owned by process
  or thread respectively) object.  Again including sub-member only
  following direct or const owning smart pointers.
- The observer pointer is a member object and the referred to object is
  another direct member of the same parent object, or it is a child of
  another direct member only following direct member ships, or only
  following const owning pointers.
- The observer pointer is member of a parent object for which the above
  rules (for observer pointer objs) are true.
- in GC mode, observer_ptr can put to what ++gc_new++ returns

How to avoid the expensive shared pointers:

- also in a graph, the graph is the owner of the nodes, not the neighbor
  nodes.  So e.g. there would be a singly linked list of nodes using
  unique_ptr, representing the nodes owned by the graph. Each node has also a
  list of non-owning pointers to it's neighboring nodes, which then represents
  the actual graph. Costs space: the additional unique_ptr per node. Costs
  run-time: unique_ptr ctor when inserting a node plus dtor when removing a
  node minus the costs the shared_ptr solution would have had.


*to-do*:

* Which smart pointer a class (e.g. a class representing a collection)
  internally uses is given as template argument.  E.g. it internally uses
  unique pointers, and data accessor methods return observation pointers.  Or
  it internally uses shared pointers, and data accessor methods return shared
  pointers.  That however means EF needs to have same const_expr which returns
  a type given an input type, and which, regarding the previous example,
  internally has the relation unique pointer -> observer pointer and shared
  pointer -> shared pointer.





== Compilation

[[ctconst]]
[[ct_execution]]
=== Compile time execution / ctconst (aka constexpr)

Extend Cpp11 (I don't know what Cpp14 offers) concept of constexpr, but
probably name it ++ctconst++.  The code the compiler generates can also be
executed right away.  Why restrict that in any way?  Maybe it gets too
difficult to write good tools (analysis, semantic aware tools for IDEs, etc).

Difficult for cross compilers?  The code really being generated cannot be
executed.  The code executed while compiling is either in the host machine
code or in some byte code the compiler can execute.

Allow using const and temporary objects.  That makes it possible that we can
call methods on literals, being really of a given class type (everything is an
object in EF), and the calls are evaluated at compile time.

The `normal' compiler receives built-in literals from the execution of the
code the meta compiler produced.

[[sharp_prefix]]
==== # prefix guideline

Consider having the guideline to use # as first char for each name (keyword or
identifier) which is ctconst.  Not only would that mean that only by looking
at a name one would know that there are no run time costs, but also that it
looks quite familiar to people with a C background: e.g.  ++#include++ (or
++#import++), ++#if++ (conditional compilation), ...


==== Conditional compiling

constexpr are evaluated at compile time.  Using that with const conditional
expression and put declaration statements into the clauses controlled by the
conditional expression we get conditional declarations.


==== Preprocessor / Macros

* EF shall provide macros, but discourage their use.  They only can be enabled
  by a style guide compile switch.
* If a language has macros / a preprocessor, it is apparently much harder to
  write tools like static code analysis or refactoring tools.
* If there is no preprocessor, how to I get __FILE__, __LINE__, __FUNC__? For
  __FUNC__ maybe something like ++thisfunc.name()++
* Even if EF has expressions evaluated at compile time which conditionally
  define/declare stuff, than macros still can assemble arbitrary text, .e.g
  only part of expressions
* Use M4?
* As separator for parameters of a macro call, interpreted by preprocessor,
  use something which is not part of the EF language.  E.g. if EF knows comma
  (,) but not semicolon (;), then e.g. the preprocessor uses semicolon to
  separate arguments.  In C&plus;&plus; its not easily possibly and sometimes
  not at all to pass an argument containing a comma.


== Namespaces in general

Classes/Modules are also namespaces.

* Somehow make it hard to accidentally shadow a name and/or to accidentally
  refer to another name as intended.  E.g. warnings if a newly introduced name
  shadows another one.  To really to that the user needs to explicitly state
  that.  I.e. an declaration in EF could have an +shadows+ attribute.  When
  that attribute is used without really shadowing a name, that too results in
  a warning.  As always, (specific) warnings can be turned off or turned into
  errors.

* When importing a namespace and a newly imported name shadows another one,
  shall this result in a warning?  Must the user explicitly state which names
  he approves/allows to shadow others. 

* When calling a method, within the argument list the name space of the
  method's class is the top namespace.  That way one is not forced to qualify
  names defined in that class which one want's to pass as argument.  A typical
  use case are enumerations.  What if the user does not want to import that
  namespace within the argument list -- shall EF give him a choice?  What if
  the act of importing the namespace would shadow names -- does that result in
  a warning -- or only if the names used within the argument list are ones
  that where auto-imported and now shadow others?

* Have the same namespace for identifiers for objects (including code objects)
  and for types and label and whatever.  This is simpler for the parser
  (closer to being context free), and also simpler for most human brains: one
  name meaning different things just is confusing.



== Composable / extendable language

=== Composable language

Each of these features the user can turn on/off by options:

- Variable sized objects, in particular arrays.  Because that introduces a
  `hidden' indirection.  So a variant would be to still allow the variable
  sized objects (C, being _the_ system language, also allows them), but one
  would be required to use a syntax where the indirection is clearly visible.
- Member method with implicit this argument, i.e. e.g. the this keyword must be
  given explicitly as first argument.  How about calling a member method?
- That yet unnamed default ``implementation hiding'' of smart pointers (which
  at the side of referencing the pointer hides the cost of dereferencing).
- Virtual methods
- [constructors: user can already omit calling a constructor by special
  initializers like e.g. `noinit']
- RAII / destructors
- Exceptions
- Bounds checking which cannot be done at compile time, i.e. which must be
  done at run time.
- Restrictions on operations allowed on pointers which make pointer alias
  analysis feasible
- Owning smart pointers
- Garbage collector

That however makes designing the standard library difficult, if the library
design does not know that the user allows and what not.  Features which have
only local costs (within a method) should be allowed in the library, that is
an implementation decision.  If the user doesn't like it, he can take another
library implementation.  Also have two parts of the library, spoken in
analogy: a C part and a C&plus&plus/STL part.  Methods which can return an
error have two versions, one using exceptions and one using the C way.

One of the goals of this ``composable language'' topic is to make it feasible
that EF can be used, if used with the required (command line) options, as a
system language with all run time costs directly visible, i.e. without any
`hidden' run time costs.  EF would then be like a ``better assembler'', or
even hopefully ``a better C''.


=== Extendable language
Literals such as strings, arithmetic, collection are just very basic from a
language point of view.  However the language allows to create aliases, and
the EF standard then supplies a number of them.  List literals l[...], map
literals m[...] etc only make use of some meta language which lets the user
define such literal constructs.


== Exceptions

See chapter 'Embedded System constraints'

Allow to disable them for users where footprint size is most important.  But
what will happen then to the signature of library functions?  Do we always
need two versions, one using return codes and one using exceptions (and using
the return value for something which allows the caller to build nice
expressions)?.  If so, probably the exception version should be the one having
to pay the penalty of having two versions, if there is a penalty at all.
Because the return code version is the one for the embedded system with hard
constrains, thus a penalty is not affordable.

When to use exceptions?

Some say Use exceptions correctly: to report an unexpected use case.  When the
function could not do what it was asked to do.  Don't use it in normal use
cases.  An exception should actually never occur at all.  But that does mean
that the N caller of `divide' is supposed to check for themselves that divisor
is not 0 (OK, if they can and want to react, they have to write the code
anyway, the question is only before the call to prevent the call or after the
call in the catch clause).  Likewise for opening a file
-- here I think it would even be the wrong solution to do it like `if
!fileexists open' because naturally between the fileexists and the open the
file can vanish.

Others say, I think ruby or python, that you should always first just try and
if it fails, try to react in the catch handler.


- As I think Stroustrup said: The whole error handling theme _is_ complex,
  don't blame the exceptions.
- Caller can decide that all/certain exceptions result in an die right away.
  E.g. because caller thinks he fulfills all preconditions or because he (and
  no one else in the call hierarchy) doesn't write a catch handler.  However
  then each exceptions needs to be translatable into a integer and or a string
  which can then be automatically printed.  That printer is user definable,
  e.g. through overload or registering a callback aka hook.
- As in Java, have an obligatory throws clause
- We can define name's for sets of exceptions, usable for throws part of
  function signature


[[templates]]
== Templates / generic programming
Each template argument has an attribute which defines whether that template
argument contributes to define a distinct type or not.  That is probably
needed for variable sized objects, see <<variable_sized_obj>>.

Similarly but probably yet different: topic of efficient implementation of
templates.  E.g. when imaging cpp unique_ptr: there only one implementation in
the program text sequence is required; that single one can serve all concrete
types since they only differ in the type pointed to.


== Optimizations

See book Writing Efficient Programs.  See also <<cheap_destructors>>.

=== Copy elision

...


=== Lazy evaluation

If its true that it is not applicable in an hard-real time environment, then
provide compiler switch to turn it off.  However would that work?  Probably
the caller module and the module implementing the function must be compiled
with the same compiler switch.


== Concurrency


[[excl_shared_access]]
=== Object property `exclusive/shared access'

See also <<obj_properties>>.  Member objects' exclusive/shared access property
is also determined by parent object's exclusive/shared access property.  If
parent allows shared access, then so must member.  If parent has exclusive
access, then a member still can have shared access, e.g. because the user
chooses an implementation based on multiple threads.


=== Reentrancy

.to-do:
- Does it make sense to mark code chunks as reentrant / non-reentrant?
- How to ensure a non-reentrant code chunk is not called by multiple threads?


=== Threads (user-level & kernel-level) / processes

...


=== Atomic operations

...

=== Locks / Semaphores ...

Provide automatic locks/... around shared resources if wished, e.g. with a
keyword stating that this is a shared object and that it shall have an
autolock.  see also <<obj_properties>>.  User may not wish that because he
wants to bundle multiple accesses to shared resources in one critical section.

=== Shared resources

Potentially but not necessarily (i.e. parts of these resources can also be
owned exclusively by one thread) shared by threads, common to one process:

Memory:: See <<obj_properties>> and <<smart_pointers>> for properties of objects / smart
pointers which aid in the topic of concurrency.
File descriptors:: ...
Signals:: ...

Shared by processes:

Memory:: ...
...

=== IPC (Inter process communication)

...

== Library

=== Provided by library vs built-in
- Optimizers & verifiers can take more advantages when things are built-in,
  right? 
- In most cases there are multiple ways to implement a given function
  signature.  Which implementation is the best depends on the problem at
  hand.  Only the user knows the problem, so he might want to choose the
  library implementation that suits his problem best.

=== Iterators
- Know their container, most of all know the bounds of the container

=== Algorithms
- Primarily work with collections, not with iterator pairs

=== Localization / Internationalization / character encoding

...


== Interaction

...


=== ABI

...


=== Talk to C API

...


=== Inline Assembler Snippets

...


[[tools]]
== Tools around

EF tries to support tools as e.g. optimizers and verifiers by making pointer
alias analysis feasible (at least more feasible than in C or C&plus;&plus;) by
only providing constructs where analysis has a change to follow where pointers
point to.  E.g. by 1) not providing pointer arithmetic (however there are
iterators) and 2) not providing integer->pointer casts.  See also
<<type_system>>.

When D has guidelines/rules how to name unnamed/temporary objects / code
chunks, then tools can profit.  The semantic intelligence of an IDE can show
them.  Also probably needed in call tree visualizations where unnamed code
chunks are part of.  In the debugger I want to visualize return values of
functions or even every expression.


=== Debugger

- Be able to display at least return value of functions call.  Maybe even the
  unnamed temporary result of each expression.
- Be able to debug all constructs (macros, templates, closures, lambdas, ...)


=== Optimizer / Verifier

See what Clang Static Analyzer does.


=== Valgrind / LLVM & Co

...


=== Profiler

The guideline is to always use the `automatic'/`smart' classes, never the
raw/built-in types like raw arrays, raw pointers etc.  Only when a profiler
shows that a certain part of the code has efficiency issues those should be
considered.


=== IDEs can have semantic understanding

Plugins for QTCreator, Eclipse, MS Studio, Emacs, Vim.  To my current
understanding, QTCreator is more often used for development of applications on
embedded systems than Eclipse, thus first start with QTCreator.


=== Pretty printer aka beautifier

...


== Style

By default enforce some white rules.  This enforcement can be turned off by
compile switch.  Nearly all style guides agree that the actual style is not
that important, any programmer can quickly get used to any style, only
consistency is important.  When the language mildly enforces a style then
there is a high chance of consistency.

Also enforce some naming style?  Uppercase for type names, class members end
or start with underscore....

By default the warning level is maximum, and warnings are treated as 


== Theory

* What profit does EF get when it tries to listen to findings, concepts from
  theory.  E.g. if it would have a truly context free grammar, what would be
  the profit -- and the costs

== Misc

* ; or , build expression lists (aka/similar compound statement).  The value
  of the whole thing is the value of the last element.  It follows that the
  value of a function body is the value of the last element, i.e. a return
  statement is no longer needed.  Allowing to omit the return statement
  especially makes small lambdas more concise/readable.
* Via compile switches one can choose whether mnemonic keywords or full/long
  keywords are prohibited.  The default is to use mnemonic keywords.  That
  results in shorter code, the reader better sees the important things in the
  code, and by being mnemonic its very unlikely that the maintainer does not
  remember the meanings of the keywords.  Many languages successfully use
  mnemonic abbreviations: ++struct++, ++defun++, ...
* As in python/Perl tuples/lists everywhere: (a,b,c) = foo_returning_3
* Read again (google) ``C and C&plus;&plus; are not context free'' --
  Trevor Jim.
* Let me initially a local var by passing it as output param to a function
  call fun void( int&, int&); fun bar() -> void { foo( int var flori noinit,
  int var edi noinit ); cout << flori << edi; }

As in Python, make it possible that a list of variables are initialized by a list
----------------------------------------------------------------------
[var i as auto, var j as auto] = gettwo();
[i,j] = gettwo();
!!!! must work for any type of collection gettwo returns !!!!
the explicit version would probably be
std::tuple<const int&,const double&>(i,j) = gettwo();
----------------------------------------------------------------------

//  LocalWords:  decl malloc IPC laterinit laterctor alist sa ary arg
 
