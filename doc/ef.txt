:encoding: UTF-8
// The markup language of this document is AsciiDoc

include::../README[]

== Designing EF


[[motivation_details]]
=== Motivation for EF revisited 

See also <<motivation_abstract>>. Thoughts about what EF could provide overall
what no other current language can provide overall.

Hard real-time / deterministic;; This is important for many embedded systems.
Any programming language with an obligatory garbage collector most probably
won't be suitable for hard real-time.  I am unsure about exceptions: there are
zero overhead implementations, 

Concurrency support;; ...

Low power consumption;; This is important e.g. for portable devices running on
battery or big server farms.  Interpreted languages in contrast to natively
compiled languages almost certainly use more power when the program is
executed (more machine instructions executed and / or more memory
consumption).  Most modern programming languages are interpreted.  However JIT
for many of them is already common, is it?  And in that case, what can be said
about the power consumption?  After all there is still a VM, a typically big
run-time, typically huge memory consumption.

Safety nets;; By default bound checks, contracts, invariants, static type
system, making it hard to accidentally drop errors.  For the user it should be
easy to the correct thing and hard to do the wrong thing.  However EF does not
try to take safety to the extreme.  Ease of use is also important.  Also EF
does not patronize the user; when the user really wants it, he can do
everything he can do it C.  I don't know where ADA and/or Ravenscar profile
fit in here.  I think they are closer to high safety than to ease of use for
my taste.  C&plus;&plus; 'if' correctly used also has adequate safety nets,
but it is too easy to accidentally do the wrong thing and IMHO too hard to the
right thing.

As direct access to HW resources as C;; Despite the default way of programming
in EF is `safe', if the user really wants he can get as raw access to HW
resources as in C.  He has to be explicit though, so it doesn't happen by
mistake and is easy recognizable.

Performance at run-time;; Help compiler in being able to do optimizations at
run-time.  E.g. with pure functions, knowing that pointers are not
aliases, etc.  Most notably try to allow for global optimizations, including
inter module.  Allow for compile-time evaluation of many constructs.  Allow
for optional optimizations at run-time.

Easy consistent syntax;; Simple things are easy to learn, easy to maintain,
it's unlikely to make accidental mistakes, it's more fun when things work as
intended and when you don't feel dumb.  C&plus;&plus; is an awful complex
language once you start to dive into the language's details.

Small run-time;; In order the binary also fits on a small embedded system.
However does not take that to really tiny (for 2014 standards) embedded
systems.  C is a good programming language for tiny programs.  Having safety
nets and abstractions starts to really pay off when programs get larger.
Anything interpreted is probably to large since the interpreter also needs
space.

Features;; OO, functional programming (includes first-class functions),
generic programming, meta programming, collections (lists, maps aka hash
tables etc) and slices thereof, regular expressions.

Notable things what is 'not' part of the motivation of EF: specially targeted
for safety-critical applications.  That allows for more freedom in what the
programmer can do and how he can do it.  I think when the language is too
pedantic and patronizing, it is not so much fun anymore using the language.


=== Competing programming languages

==== C
Way too few safety nets.  Way too few of the conveniences other classic and
modern programming languages provide.


==== C&plus;&plus; (including newer versions)

Way to complicated syntax and rules, mostly due to it's C legacy.  It's
quicker and arguably more convenient to do the `unsafe' C thing than to do the
`safe' modern C&plus;&plus; thing.  E.g. make use of STL collections with
bound checks or make use of smart pointers.  C&plus;&plus;11 added support for
concurrency.  Since that's via the STL that is too much an add-on as built-in
into the language as it is the case with Ada.


==== Ada (including newer versions)

I can't judge Ada since I don't know it.  The first impression is that it
offers much of what EF wants and what is objectively measurable.  My
subjective first impression is that it feels a bit verbose.  Voices on the
internet say it's OO feels attached rather than properly built-in.


==== Real-Time Java 

I suspect the run-time to be too big for small embedded system.  Since it's
still interpreted, I suspect the power consumption to be still higher compared
to say C&plus;&plus;1.  Modern compilers / run-times might really have decent
on-average performance -- I'm not convinced yet that this good enough when you
want to be sure certain parts are always (not on average) really fast.  Java
is weak in directly accessing HW resources on a level as C can.


==== Lisp
Is apparently often used in robotics.  It is interpreted and has garbage
collection.  Is thus not suitable for a hard real-time embedded system.

.to-do:
* Read Wikipedia's ``Comparison of Java and C&plus;&plus;''
* http://www.embedded.com/design/prototyping-and-development/4024892/Ada-and-Java-real-time-advantages
* http://www.adacore.com/uploads/technical-papers/concurrency-comparison.pdf
* Book: Real-Time Systems and Programming Languages, look for newest edition
* Google for ``Chris Lattner’s theory of compiler design''


==== D
...

=== Guidelines in designing EF

* Easy grammar / KISS / feasible to write tools for EF:
 ** Most of all easy for humans to understand the _complete_ EF programming
    language, down to every corner case.  Some languages are intuitive for
    humans in most cases, but their chosen ``easynesss'' results in very hard
    to understand special cases.
 ** KISS.  Only few people are interested in delving into complicated daunting
    language details.  Most just want to use the language.  That is especially
    true in the industry, and I want EF to be applicable for embedded systems.
 ** I believe that an easy grammar for humans results in most cases also in an
    grammar that is easy to understand for machines, i.e. its easy to write
    tools for EF.  If it's easy to write tools for EF, that helps that EF is
    actually being used.
 ** Clean code can be reads as English prose.  You read the code from left to
    right and directly get English prose describing what happens in the order
    you read it.
  
* No redundancy (``redundancy is the primary enemy of a well designed
  system'').  User shall not be forced to anything twice.  With identifiers of
  various (meta-) types the user can define various things exactly once.

* Each thing / feature of EF has only exactly one responsibility
 ** Applies also to keywords / operators in EF
  *** Avoid the case that one keyword affects multiple different things at the
      same time, especially regarding storage, lifetime, scope, linkage.
  *** Context insensitive, a keyword/operator has always the same meaning in
      any context
  *** Choose linkage, lifetime, storage, scope, alignment etc with dedicated
      keywords.
 ** EF shall help that the constructs the programmer creates adhere to this
    principle
 ** Const local objects -- apart from loop variables, collecting/summing up
    variables, it's hard that one object with given name really can reasonably
    contain different values at different times.

* How EF shall name the features it provides: In general any builtin feature
  is named via one to three of the following three variants:
 1. Punctuation (e.g. +++++ for arithmetic plus).
 2. Something _very_ short, a few characters, consisting of punctuation and /
    or letters (e.g. ++s*++ for a shared pointer), the abbreviations only
    being mnemonic.
 3. Complete English words (e.g. ++dynamic_cast++).

* At its core, EF does not patronize the user.  It leaves the decision what is
  `good' and what is `evil' up to the user.  People / projects have different
  needs, and need different guidelines of what is good and what is evil.
  However:
 ** Trough builtin customizable style guidelines a soft attempt is made to
    give project owners / architects, not the individual programmers, a tool
    to soft enforce the project's guidelines.
 ** Through the built-in default style guidelines a soft attempt is made that
    most users / projects will keep these defaults and don't customize them,
    so an average EF program has the same style guidelines and thus looks
    familiar to everybody.
  *** Most guidelines about technically unimportant things such as formatting,
      which includes white spaces, agree that its mostly about consistency,
      not about which formatting is better or worse.  But with most
      programming languages, each project which wants any consistent
      formatting is forced to make up a set of formatting guidelines which, if
      at all, are only verified by a third party tool.  With EF's default
      guidelines, a project wanting any consistent formatting can do nothing
      and thus automatically will get EF's default style guidelines which are
      enforced by the EF compiler.
 ** What the designers of EF think is `good' is what is made convenient to use
    by providing short constructs.  What the designers of EF think is `evil'
    can be used, but longer constructs have to be used.  These longer `evil'
    constructs stand out relative to the shorter `good' constructs, and are
    thus more apparent to the reader / maintainer, catching the attention that
    there is a potentially `evil' construct.  Additionally, some constructs
    might also be prohibited by the default style guidelines, in which case
    the user is also forced to customize the style guidelines.

* Don't degrade a good design to also cover weird special cases -- put the
  burden of having to use workarounds on the people with the strange
  requirements.

* Don't pay what you don't need (from C&plus;&plus;'s guidelines)

* As in many modern languages, abstractions and checks at compile time and
  run-time shall make programmer's life easier with no or very little overhead
  compared to C.  That is, the default way and the most convenient way to
  program in EF is that way.  You still can use the raw features which C
  provides, but you have to explicitly say so.
  ** RTTI costs, mainly footprint size, which might be a problem in an
     embedded system.  As in C&plus;&plus;, allow to turn it off - but then we
     also loose exceptions?  See
     http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment.

* Trade safety (likeliness to write correct programs) for compile time.  The
  machine has to think, not the human programmer.  Compile time (almost) only
  helps the programmer, but the programmer benefits probably more if he spends
  less time searching bugs / compile/linker problems.
 ** No context sensitive operators/keywords.
 ** With a compile switch disallow the potentially dangerous `from the world
    C' constructs which the verifier can not verify to be correct.

* Trade faster run-time for longer compile-time.  The program is more often
  run than compiled.  Even while developing - why compiling a translation unit
  if you don't let the code in it run?  (OK due to a changed import it might
  has to get recompiled).

* Make it easy to write correct and run-time efficient code, make it and hard
  to write incorrect code, make it obvious when run-time efficiency has more
  than a near zero overhead compared to the C equivalent construct.
 ** Full control as in a C program is still possible, however at the cost of
    less short & nice syntax.  That is intentionally, it should be explicitly
    visible that on purpose for some reason the potentially dangerous C style
    has been used.  But don't go as far as making low level code too bulky,
    because then nobody will want to write a whole file in that manner.
 ** Concerning run-time overhead compared to the equivalent C construct: Does
    it make sense to have 3 levels: 1) guaranteed to have zero overhead 2)
    near zero overhead, around 1-3 machine instructions 3) More.  It does not
    mean that every construct shall have those three in parallel, it only
    means it should easily be recognizable / memorable into which level a
    construct falls.

* For the cases where there exists facts and data that a given abstraction
  (say e.g.  smart pointers) helps the programmer to write less bugs at little
  near zero or even zero run-time costs, people still might object using these
  abstractions.  Because they don't know the facts/data, or don't believe
  them, or they really have a special case where the `near zero' overhead
  becomes a noticeable overhead.  Especially in the embedded hard real-time
  world people want full control.  So EF has to provide full control if it
  wants to have a chance to be accepted.
 ** provide compile switches for style guides.  Then project's guidelines can
    choose whether they want to allow C features for ultimate control or
    disallow them for more safety at nearly zero run-time costs.

* It shall be possible for the programmer to directly express what he wants to
  accomplish.  However that is only possible if (the designers of) EF can
  anticipate what the user want's to accomplish.  The more EF anticipates, the
  more ``overloaded'' EF becomes.  Probably restrict that anticipation to
  (currently) well known patterns in procedural, OO, functional, generic
  programming.


Inspiration: don't re-invent the wheel -- look at how lisp and other language
solve problems:

- I like the http://en.wikipedia.org/wiki/Unix_philosophy[Unix philosophy].
  When can these guidelines in designing EF learn from them?
- Targeted toward embedded system.  C / C&plus;&plus; / Lua / Tcl / Ada /
     Ravenscar profile / Hume / embedded C&plus;&plus; / Java Real-Time
- OO: C&plus;&plus; / D / Java / C# / Ruby / Python / Eiffel
- Functional programming: Lisp, Smalltalk, Scheme, Ruby, Python
- Generic programming: C&plus;&plus; / D
- F#, OCaml (boasts to be nearly as fast as C)


=== Embedded system constraints

* http://electronics.stackexchange.com/questions/3027/is-c-suitable-for-embedded-systems
* http://www.inf.ed.ac.uk/teaching/courses/es/PDFs/lecture_5.pdf        
* http://741mhz.com/exceptions-performance/
* http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment
* http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.8024&rep=rep1&type=pdf  
* http://forum.dlang.org/thread/unreajijtwafywprqaag@forum.dlang.org?page=2#post-op.wmhetvpwsqugbd:40fbsdx64.lan
* http://programmers.stackexchange.com/questions/84514/why-does-c-dominate-in-the-embedded-software-market
* Book: Real-Time Systems.  Design Principles for Distributed Embedded
  Applications.  Kopetz,  Hermann.
* From http://stackoverflow.com/questions/1601893/why-are-c-c-and-lisp-so-prevalent-in-embedded-devices-and-robots
  2/3:
 ** deterministic memory management
 ** access to well-defined bit sizes (still not sure how LISP fits in here)
 ** simple execution environment
 ** entirely functional (natural fit for concurrency) or general purpose
    (flexibility, embedded systems often have special needs)
 ** flat memory model
* From http://www.stroustrup.com/abstraction-and-machine.pdf:
 ** Bit, byte, pointer, and array fiddling should be the last resort rather
    than the first choice.  C&plus;&plus; balances costs with benefits for
    “advanced features”, such as classes, inheritance, templates, free store
    (heap), exceptions, and the standard library.  If you need the
    functionality offered by these facilities, you can rarely (if ever)
    provide better hand- coded alternatives.  The ISO C&plus;&plus; standard
    committee’s technical report on performance [ISO, 2005] is provides data
    and arguments for that proposition.
 ** Exceptions (throw/catch): The time needed to handle an exception depends
    on the distance (measured in function calls) from the throw-point to the
    catch-point and the number of objects needed to be destroyed on the way.
    Without suitable tools that’s very hard to predict, and such tools are not
    available.  Consequently, I can’t recommend exceptions for hard real time;
    doing so is a research problem, which I expect to be solved within the
    decade.  For now, we must use more conventional error-handling strategies
    when hard real time is needed, and restrict the use of exceptions to large
    embedded systems with soft real time requirements.
* to-do: Read The ISO C&plus;&plus; standard committee’s technical report on
  performance [ISO, 2005]:
  http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf
* Is it really the case that for many embedded systems only a C compiler is
  available, which would mean that at least EF compiler is needed which's
  output is C?  However that would be horrible to debug, would it?  And isn't
  it easy enough to write a back end for GCC or LLVM for someone wanting to
  write EF for his embedded system where he currently only has some C
  compiler?
* Mind that most of the time only a small part of the embedded system is under
  hard real-time constraints.  What benefit can we draw from that?
  ** Turn off exceptions completely for all or only a subset
  ** If it is the case that one exception implementation is on average better
     than another, but the second is better for real-time because of better
     predictability, than maybe let the user choose.
* Are exceptions compatible with the idea that EF should be applicable in a
  real-time environment ?
 ** See above, Stroustrup's opinion.
 ** http://stackoverflow.com/questions/5257190/are-exceptions-still-undesirable-in-realtime-environment
 **  http://741mhz.com/exceptions-performance/
 ** Also when I use return codes it's no difference in difficulty to
    measure/guess/prove how long a call takes in the worst case.
* Anyway, even if modern exception implementation would be suitable in an hard
  real-time embedded system, there still might be reluctant people who are in
  charge, so EF maybe still needs a way to turn exceptions off as
  C&plus;&plus; can.
* An embedded system often does have things a normal OS has: files,
  processes/threads?, ... What is the influence on EF's stdlib?

=== Respect computer science theory

* What profit does EF get when it tries to listen to findings, concepts from
  theory.  E.g. if it would have a truly context free grammar, what would be
  the profit -- and the costs


== Introduction

=== Meta syntax used in this document

https://github.com/sensorflo/yasmala[Yasmala] is the meta syntax (aka
notation) used in this document to describe the syntax of EF.


=== Terms

implementation-defined behavior;; Similar to C&plus;&plus;.  The EF
specification must specify the range of possible behaviors.

side effect;; As C&plus;&plus;: A change in the state of the execution
environment: 1) Accessing an object designated volatile 2) modifying an object
3) calling a library I/O function 4) calling a function that does any of
those.

undefined behavior;; As C&plus;&plus; -- However the hope is that EF has no
constructs with undefined behavior.  Note to myself: undefined behavior
includes that the implementation deliberately chooses a specific behaviour and
optionally documents it.

unspecified behavior;; Similar to C&plus;&plus;.  Contrary to C&plus;&plus;,
the EF specification must specify the range of possible behaviors.

well-formed program;; As C&plus;&plus;


=== Program structure

In EF everything is composed of expressions, thus a program is just an
expression.  See chapter <<expressions>>.
----------------------------------------------------------------------
program = sa_expr;
----------------------------------------------------------------------


== Lexical structure


=== Source file character encoding
Source files optionally start with something that specifies the character
encoding of the source file.  The compiler can be told what character encoding
it should assume if its not explicitly defined at the beginning of the file.
If nowhere defined explicitly, it defaults to UTF-8.


=== Identifiers

Similar as in C&plus;&plus;.  Regarding the optional leading sharp sign, see
<<sharp_prefix>>.

----------------------------------------------------------------------
identifier = [\#]'[a-zA-Z_]'[a-zA-Z_0-9]+;
new_nonempty_identifier = identifier | 'none;
new_identifier = [new_nonempty_identifier];
----------------------------------------------------------------------


[[comments]]
=== Comments / Documentation / EFDoc

----------------------------------------------------------------------
comment = 
  \/(\*+) ... \1\/ | ## multi-line
  ("//"|"#!") ... \n ;  ## single-line
----------------------------------------------------------------------

The multiline variant can be nested.  E.g given ++a /* b /* c */ d */ e++,
from b to d inclusive is within the outer comment.  The closing delimiter
needs as many stars as the opening delimiter.  That way sequences like */ can
be included in the comment: `/** in EF the */ ends an comment **/`.

Allowing "#!" as single line comment allows for the ``shebang'' mechanism.
Control with style guidelines that it is only used as first two characters in
the file.  Note that the hash has another meaning when not followed by an
exclamation mark, see <<sharp_prefix>>.

.To-do
- Institutionalize using Doxygen or Doxygen like markup language.
- See EFDoc why it makes sense to integrate the doc language into the
  compiler.
- Inherited classes, overloaded methods, overwritten methods,
  member-getter-setter, delegate methods: Find a way that only a minimalistic
  comment (one keyword) or none at all has to be written and still have 1)
  good doc output 2) even in code the maintainer sees quickly that the
  identifier is not documented here but at another place.


==== EFDoc

Everything up to the first occurrence of the sequence ``++@.++'' belongs to
the _brief part_.  The rest is in the _details part_.  Considerations: Make it
feasible to use dot for abbreviations in the brief part.  Make it feasible to
auto fill EFDoc text.

Default to which <construct> a doc comment belongs: ++fun <fun name> fun
<param_1> param_1 ... <param_n> param_n <ret_type> fun <fun body>++.
Overwrite with a leading ++<++ or ++>++ to set the construct to which the doc
comment belongs.  There can be multiple doc comments before / after a
construct.  Each construct 


[[expressions]]
== Expressions

In EF everything is an expression.  There is no such thing as an `statement'
as it is the case in e.g. C, C&plus;&plus; or Java .  Every expression is in
one of these two syntax forms:

* _operator expression_: An unary/binary/n-ary operator as in ++a * b++.  See
  <<operator_expr>>.
* _list expression_: See <<list_expr>>.

----------------------------------------------------------------------
program = block_expr;
block_expr = standalone_expr_seq;
standalone_expr_seq = (standalone_expr [\;]{l?})+;
standalone_expr = sub_expr;
sub_expr = operator_rt_expr | primary_expr;
primary_expr = list_expr | literal | ID | group_expr | mi_end_expr |
  'this | 'super;
list_expr =
  obj_def_list_expr |
  type_def_list_expr |
  flow_control_list_expr |
  memory_mgmt_list_expr |
  explicit_rt_expr |
  explicit_type_expr;
----------------------------------------------------------------------

- _standalone expression_ (aka mini block expression): See <<standalone_expr>>.
- _standalone expression sequence_: See <<sa_expr_seq>>. 
- _sub expression_: Part of an enclosing expression, can be operand to an
  operator.
- _primary expression_: Leaf of an operator expression tree.

.To-do
- Read http://en.wikipedia.org/wiki/Monad_(functional_programming)
- I want a mostly context free grammar.  That is easier for human brain and
  for compilers.  100% is probably is not possible.  E.g at global scope, an
  arithmetic operator is meaningless.  Then again, maybe we can allow that.
  Such expressions, as initialization of static variables, are executed in
  undefined order at program start-up.  EF doesn't patronize the user.


[[list_expr]]
=== List expression

A list expression resembles the syntax and the idea of a function call
(++foo(arg1, arg2)++).  Logically a list expression is a `function name' and
an argument list.

------------------------------
func  arg      arg1   arg    arg2  arg     arg3  list
name  list            sepa-        sepa-         close
      open            rator        rator         deli-
                                                 miter
if              a       :     b    else     c      $
if     (        a       :     b    else     c      )
if              a       :     b    else     c   end if
[               a       ,     b     ,       c      ]  
{               a       ,     b     ,       c      }  
------------------------------

The pattern is always the same: A leading `function name' which is either a
keyword or some punctuation.  Followed by an optional left-parenthesis being
the argument list open delimiter (*to-do*: reconsider that -- it creates
ambiguities in cases such as function definitions where a left parenthesis can
also be an separator).  Followed by an argument list where the arguments are
separated by separators.  The valid separators are specific to the `function
name'.  For example the +if+ `function' has ++:++ or +else+ as argument
separators.  The list expression is closed / delimited by a dollar or right
parenthesis.

----------------------------------------------------------------------
list_expr = fun_name args_open_del naked_arg_list args_close_del;
args_open_del  = [\(];
naked_arg_list = (argument argument_separator{l?})*;
argument_separator = ... ; ## depends on concrete list
args_close_del = \) | \$ | 'end |
  'endof (id | \( id* \) );
----------------------------------------------------------------------

The spirit of the ++endof++ close delimiter variant is to provide a way to
make clear which construct is being ended.  The id (or multiple ids within
parentheses) after ++endof++ is free from a syntax point of view.  Built-in
configurable style guidelines will enforce that it (they) `matches' the
beginning of the list expression.  E.g. an +if+ must be closed with +endof if+,
a ++fun foo ...++ must be closed with ++endof (fun foo)++.

The argument list open delimiter and the argument list close delimiter can be
freely mixed from a syntax point of view, also if that looks awkward for
humans.  Both ++if ( a : b $++ and ++if a : b)++ are syntactically valid.
Such `mismatches' will be caught by built-in configurable style guidelines.

Note that in ++{a, b, c}++, the opening brace ++{++ is considered the
`function name'. The `function' ++{++ creates a literal list, see
<<literal_list>>.

Note that a function call as a whole looks like an list expression, but actually is
an <<operator_expr>>, see <<code_chunk_call>>.  It's a binary operator with
the rhs being an expression delivering an code object, and the lhs being an
argument list.


**to-do:*

- Depending on the context, the list is interpreted / evaluated-at-run-time
  differently.  Define all possible variants more detailed.  This definition
  must be easily rememberable by humans.
  * Argument list when calling a function
  * Parameter list when declaring a function
  * The sequence of expressions constituting a block (aka body)
  * Expressions involving expressions lists such as e.g. ++[a,b] = [c,d]++
    which is another way of writing ++a=c b=d++. !!! Especially here, when
    should comma be in the sense of a Python tuple and when in the sense of a
    C++ comma!!! Possible answer: its always in the sense of a tuple (aka
    compile time expression list), and the directly enclosing construct
    defines what is done at compile-time and what at run-time. 
  * ...
- Introduce a term like _form_ (from lisp) denoting the general concept
  which's specialization are a) regular functions (term?) b) `compile time
  functions' like +if+ (term? I think this is what lisp denotes `form').
- Settle for a name.  Currently these are floating around:
 * expression list +expr_list+
 * compile time (expression) list +ct_list+
 * sequence +seq+
 * tuple
 * runtime sequence
 * data list

[[literal_list]]
==== Literal lists +{...}+

----------------------------------------------------------------------
literal_list = \{ (sub_expr \,{l?})* \};
----------------------------------------------------------------------

to-do:
- What is the difference to (...) or [...]? At least the content of all of ()
  [] {} is always a `literal list'.


[[operator_expr]]
=== Operator expressions / operators

These operators correspond to what is found in most programming languages.

----------------------------------------------------------------------
operator_rt_expr = boolean_expr | bit_expr | comparison_expr |
  arithmetic_expr | assignment_expr | fun_call_expr | regex_expr |
  subscript_expr | ct_list_expr | obj_def_op_expr | flow_control_op_expr |
  data_obj_def_op_expr | other_operator_rt_expr;

arithmetic_expr =
  ('root2 | 'log2 | 'loge | 'log10 | \+ | \-) sub_expr | 
  sub_expr (`+ | `- | `* | `/ | `% | 'pow | 'root | 'logb) sub_expr;

bit_expr = 'bit_not sub_expr |
  sub_expr ('bit_or | `| | 'bit_nor | `~| | 'bit_and | `& | 'bit_nand | `~& |
            'bit_xor | `^ | 'bit_nxor | `~^ |
            'shr | `>> | 'shl | `<< | 'sar | 'sal | 'ror | 'rol ) sub_expr;

## all are short circuit operands, they don't evaluate second operand if
## outcome is determined after evaluation the first operand.  Thus they can
## also be used as flow control operands, e.g. as in Perl "foo() or die()".
boolean_expr = 'not sub_expr | sub_expr boolean_bin_op sub_expr;

boolean_bin_op = 'or | `|| | 'and | `&& | `^^ | 'xor | 'nand | `!&& | 'nor | `!|| ;

comparison_expr = sub_expr (`== | `!= | \< | \> | `<= | `>= | `<=>) sub_expr;

assignment_expr = sub_expr (`\= | `+= | `-= | `*= | `/= | `%= | ... ) sub_expr;

regex_expr = sub_expr (`=~ | `!~ ) sub_expr;

subscript_expr = sub_expr \[ (index_expr \,{l?})* \];
index_expr = sub_expr | range_expr;  
range_expr = sub_expr \: sub_expr;

ct_list_expr = sub_expr#element ( 'x | `*, ) sub_expr#repeat_count;

other_operator_rt_expr =
  \@ sub_expr | ## pointer object access
  sub_expr `?: sub_expr; ## null coalescing operator
----------------------------------------------------------------------

Note that the term `operator expression' is not entirely well defined.  Both
grammar symbols +operator_rt_expr+ and +standalone_expr_seq+ (see
<<sa_expr_seq>>) are `operator expressions', but only the former is named as
such.  Also from a grammar point of view nothing indicates that
+standalone_expr_seq+ is also an `operator expression'.  Also it's not clear
yet whether type expressions are composed of `operator type expressions'.


[[sa_expr_seq]]
[[seq_operator]]
==== Standalone expression sequence / sequence operator ";"
The previously introduced operators have sub expressions as operands.  The
_sequence operator_ ";", being a binary left-associative operator, has
<<standalone_expression>>s as operands.  The value of the lhs operand (being a
standalone expression) is thrown away.  That standalone expression is thus
used for side-effects only.  The value of the sequence operator expression is
the value of the rhs operand.  The sequence operator is thus comparable to
C&plus;&plus;'s comma operator.  _standalone expression sequence_ is the term
used for the expression resulting from using the sequence operator.

----------------------------------------------------------------------
standalone_expr_seq = ...;
## See chapter <<expressions>>. Later it should redundantly be repeated here
## for the reader's convenience.
----------------------------------------------------------------------

Note that the semicolon is optional.  That means that the sequence operator is
implicit when two standalone expressions are adjacent.  The semicolon is the
explicit form of the sequence operator.

Style guidelines:

- Of a given standalone expression sequence, all sequence operator tokens are
  semicolons, or all sequence operator `tokens' are blanks.
- The blank `token' cannot be used if its rhs and lhs are on the same line.
  Note that this helps to prevent the accidental invocation of an operator
  list (e.g. ++-(...)++) where the user wrongly used parentheses ++(...)++
  instead ++g(...)++to group a sub expression.


[[block]]
=== Block expression
When a local object is defined (see <<local_object_def>>) the storage needed
for that object is allocated and associated (see <<associated_block>>) with a
block.  The block is then the owner of that storage.  At the end of a block,
all storage owned by the block is freed.  (*to-do*: Elaborate who exactly is
the owner of the local objects.  It is the owner who es responsible to
destruct them).

--------------------------------------------------
block_expr = ...;
## See chapter <<expressions>>. Later it should redundantly be repeated here
## for the reader's convenience.
--------------------------------------------------


[[standalone_expression]]
[[mb_expr]]
=== Standalone expression / Mini block expression
A _standalone expression_ (aka _mini block expression_) is comparable with a
statement in C or Java.  It either is 1) the lhs operand of the expression
sequence binary operator, or it is 2) the rhs operand of the sequence operator
or the argument to an enclosing list expression.  In the former case its value
is thrown away, see <<seq_operator>>.  That is unlike a sub expression, whose
value is always used by the enclosing expression (although that one might
throw it away without looking at it).  In the later case its value is used as
argument to the enclosing expression.  Standalone expression delimit the
storage duration of <<temporaries>>.

--------------------------------------------------
standalone_expr = ...;
## See chapter <<expressions>>. Later it should redundantly be repeated here
## for the reader's convenience.
--------------------------------------------------

Style guideline: If the standalone expression is an operator expression, it
must be one with a side effect as primary responsibility (e.g. infix/postfix
increment/decrement, one of the assignment operators, notably excluding
function call operator invoking a non-void code block).  Have a keyword or
annotation or something to mark an expression as `ok', e.g. explicitly type
cast the whole expression to void.  *to-do*: How to handle overloaded
operators which really are function calls?


=== Order of evaluation / side effects

In the following, operators / operands / evaluation are regarded as a
specialized variant of `arguments' / `functions´ / `function call'.
`Evaluating an argument' means recursively evaluating the call tree rooted at
the said argument.  The order of evaluation of `arguments' of `functions' is
unspecified within the following bounds:

- After the `function' returns, all its side-effects have been completed.
- After evaluating the first `argument' of a given `function', all of the
  remaining `arguments' of the same `function' must be evaluated before any
  `argument' of another `function' can be evaluated.
- Short circuit operators (+and+, +or+, ...) and most list expressions
  (+if+, ...) are allowed to not evaluate some of their arguments at all.

It follows that: 

- All `arguments' appear to be fully evaluated, inclusive side-effects, before
  the `function' is invoked.
- It's unspecified behavior but not undefined behavior what happens when one
  `argument' write accesses an object and another `argument' also read or
  write accesses the same object.  One or the other happens before the other,
  but no other behaviors can happen.  *to-do*: what should a compiler do if it
  detects such a case?  Requiring it to detect all cases a) is only possibly
  for all cases at run-time b) probably imposes to much run-time costs.  A
  proper function internally can, from a defensive point of view, read and
  write access any object, so it's probably not feasible to detect whether two
  functions read and write access the same object. 


Motivation:

- Make different calling conventions feasible.  E.g. depending on in which
  order arguments are passed to functions, one or the other order of
  evaluating arguments is more natural.
- Specify as much as feasible, in order to make the `uncertainty' as small as
  possible.
 * It helps to reason about when exceptions can occur
- Treating operators the same as functions is more uniform, also when
  considering that operators can be overloaded and then become true functions.

See also:
- http://en.wikipedia.org/wiki/Evaluation_strategy
- http://en.wikipedia.org/wiki/Out-of-order_execution

=== Grouping sub expressions / overriding precedence

++g(...)++ groups expressions to override precedence.  Most other languages
use just regular parentheses.  

----------------------------------------------------------------------
group_expr = "g(" standalone_expr_seq \);
----------------------------------------------------------------------

Rational for not using normal parentheses: parentheses are already used for
many things: as function call operator, as part of the +new+ operator
expression and in list expressions as delimiters.  If parentheses are also
used for grouping, there too many ambiguities. 


[[compile_time_type]]
=== Compile-time type
Each expression can be seen as actually being two expressions: 1) One is
evaluated at compile time, and it's return value is of a `compile-time type'
2) The other is evaluated at run-time, and it's return value is an object of a
`run-time type'.  Both can be `none', `void' or any other type within the
corresponding meta type set.

For example:

- Declaration expressions have only a compile-time component and no run-time
  component.

- Definition expressions (a definition being a super set of a declaration) has
  additionally also a run-time component: initializing the object.

- Most other expressions only have a run-time component and no compile-time
  component.

The compile-time types currently are one of `type' or `unknown'.

+type_expr+ is parsed (*to-do*: is `parsed' the correct word?) differently
from +block_expr+.  So to parse an expression, we need to know whether we are in
meta type `unknown' context or in meta type `type' context.  The top level is
`unknown'.  Some grammar rules impose `type' meta type context on their sub
elements (*to-do*: what is the correct word?).  At a few places the thus given
meta type context is not what you intend to have, and you want to explicitly
change the meta type context.

--------------------------------------------------
explicit_rt_expr = ('rte|'rt_expr) [\(] sub_expr args_close_del;
explicit_type_expr = ('te|'type_expr) [\(] type_expr args_close_del ;
--------------------------------------------------

*to-do*:

- The current `definition' is a complete mess.  It definitely needs to be put
  on a firmer foundation.
- More possible compile time type: `type', `run-time', `identifier',
  `modifier', or `unknown'.


[[types]]
== Types

Each <<object>> has a (run-time) type.  Run-time types are divided into
<<fundamental_types>> and <<compound_types>>.  Each type has a set of
<<type_qualifiers>>.

[[type_expr]]
--------------------------------------------------
type_expr =
  type_qualifier* (fundamental_type_expr | compound_type_expr) |
  type_expr_indirection;

type_expr_indirection =
  identifier | ## name of a custom type
  "g(" type_expr \) |  ## to change precedence of type expr operators
                       ## maybe not needed now, but maybe in future
  explicit_type_expr;
--------------------------------------------------


[[fundamental_types]]
=== Fundamental types

More or less those of C&plus;&plus;

----------------------------------------------------------------------
fundamental_type_expr =
  ## arithmetic types
    ## integral types. probably some need to be moved into stdlib
    ['u|'s].(
      'efbyte#*not necessary 8bit*#|'short|'int|'long|'longlong|
      ['f['ast]|'l['east]]'int('8|'16|'32|'64|'128|'258) |
      ['bigint|'intx]) | ## probably needs to be moved into stdlib
    ## floating point types
    'float | 'double | 'longdouble | 
    ## character types. value is code point. maybe move some to lib. would
    ## have to be variable with anyway, no? How does C++ do it?
    'char | 'wchar | 'utf8char | 'utf16char | 'utf32char
  'bool |
  'tnull | ## type of the null literal
  'void;
----------------------------------------------------------------------


[[compound_types]]
=== Compound types

* Raw general pointer
 ** <<raw_ptr>>
 ** Raw pointer to member
* <<raw_array>>
* <<function_type>>
* <<enumeration>>
* <<class>>

----------------------------------------------------------------------
compound_type_expr =
  generic_pointer_type_expr |
  array_type_expr |
  enum_type_expr | 
  function_type_expr | 
  class_type_expr | 
  union_type;
----------------------------------------------------------------------


[[raw_ptr]]
==== Raw pointer
Comparable to C's pointers.  It's intended that the user nearly always uses
smart pointers and nearly never raw pointers directly.  See also raw_ptr in
<<smart_pointers>>.


[[raw_array]]
==== Raw array

A _(fixed size) raw array_ is comparable to C's arrays.  Syntax: see
+array_type_expr+.  The size is part of the type.
++raw[sub_expr#size]type_expr++ is from a logical point of view equivalent to
++raw_array<sub_expr#size,type_expr>++.

Size must be known at compile time.  Zero sized arrays are allowed.  The size
can be omitted if it can be deduced from the initializer list, e.g. in ++var a
: raw[]int = {2,4,8}$++ the size 3 can be deduced.

Creating a pointer to the one past the end element and possibly dereferencing
it is allowed.  Note that this includes zero sized arrays.

Standard style guidelines disallow its use.  It's intended that the user
nearly always uses collections and nearly never raw arrays directly.

Syntax to construct an array object is the same as constructing any other
object.  Constructing an array naturally includes constructing its member
elements.  The constructor expects one argument which is a collection or an
iterator.

----------------------------------------------------------------------
var a({1,1,2,3,5}) : raw[5]int$
var a : raw[5]int = {1,1,2,3,5}$
var pa : raw*raw[5]int = new raw[5]int({1,1,2,3,5})$
----------------------------------------------------------------------

*to-do*: 

* Do array elements of zero size impose any problems?


[[variable_sized_raw_array]]
_Variable sized raw arrays_ are arrays which size is determined at run time
at construction time, but cannot be changed afterwards.  That is unlike
dynamic arrays (vectors in C&plus;&plus), where the size can be changed
anytime during run-time.

Probably a variable sized raw array is not really distinct primitive type of
its own, but is a composition of other primitive types: E.g. a local `variable
sized raw array' really is a local `const non-owning raw pointer' to an
unnamed `_proper variable sized raw array_' owned by the stack.  That view might
be important for the case where we want to make any costs, e.g. pointer
dereferencing, clearly visible.


[[enumeration]]
==== Enumerations / compile-time sets
Enumerations are an list of named constants.  Each is initialized at compile
time with a constexpr.  That list is then an distinct type.  Somewhat similar
to a class.  User chooses underlying type, e.g. for integral members user can
choose byte, short, int etc.  Objects of an enumeration type can only assume
values being members of the enumeration type's list.

Thus an enumeration in EF is more like a set, possibly ordered, which is
completely defined at compile time.  Maybe reflect that in the type name,
i.e. use another name than ``enum''.

An enumeration type is a collection and consequently there is an iterator
for it.  And/or there is a class static method like e.g. +ToCollection+.  You
could thus write ++for var e$ in EMyEnumaration.ToCollection() : ...$++ or
even ++for var e$ in EMyEnumaration : ...$++

If the elements in the enumeration type are comparable, then the enumeration
is an ordered list.  Make it an compile warning if the source code lists them
in the `wrong' order.
   
* User chooses whether enclosing namespace gets the names and/or if they are
  contained in the enumeration namespace
* Each enum is, as everything, an object which name as a string can be
  retrieved.  Probably that's something EF should provide in a more general
  sense: for each identifier provide a ctconst #name method e.g. foo.#name()
  delivers "foo".



[[builtin_types]]
=== Built-in compound types
Built-in types can be seen as built-in classes; wrappers around primitive
types.  Collections, iterators, 


==== Smart pointers
Are described in <<smart_pointers>>.


==== Strings & Characters

Consider distinguishing between a ``raw string'', which really is a raw array
of ++char++s with a terminating null character (i.e. not an own distinct
type), and a +string+ which is comparable to a C&plus;&plus; +string+.  A
notable difference is that +string+ additionally redundantly stores the
string's length, which gives O(1) instead O(n) time complexity for getting the
string length or the last character.  Depending on the suffix, a string
literal is a const raw array of chars or a (const?) +string+, see
<<literals>>.  In case of +string+, the string length shall be computed at
compile time.


===== Character encoding

Differentiate between 1) the type, e.g. unicode_char, which is capable of
holding any code point and 2) the character encoding into a stream of another
type, typically 8bit bytes, e.g. utf-8 or utf-16.


===== Internationalization
...


==== Collections & iterators

...


[[literals]]
=== Literals

-------------------------------------------------------------------------------
literals = literal_list | arithmetic_type_literal | bool_type_literal |
  tnull_literal | string_literal;

arithmetic_type_literal =
  ## integral types
    ## optional radix and value's first digit
    ( ['0 ['b #*2*#| 'o #*8*#| 'x #*16*#| 'r'[0-9]+'r #*custom*#] '_?] '[0-9a-zA-Z_] |
      '[1-9a-zA-Z_] )
    ## value's 2nd+ digit
    '[0-9a-zA-Z_]*
    ## suffix determines exact type
    ...

  ## floating point types
  ...

  ## character types
    ## prefix determines type of allowed escape sequences
    ...
    ## actual character
    \'...\'
    ## suffix determines exact type
    ...
  ;

bool_type_literal = 'true | 'false;

tnull_literal = 'null;

string_literal =
  ## prefix determines type of allowed escape sequences
  ...
  ## actual string
  \" ... \"
  ## suffix determines exact type
  ['a]; ## raw array of chars instead string
-------------------------------------------------------------------------------

Integral types literal: Custom radix might be a number between 2 inclusive and
36 inclusive.  The digits allowed in the literal start at 0 and end according
to the radix.  The digits above 9 are represented by Latin letters, the case
is ignored.  The underscore has no meaning and is meant to provide visual
grouping of digits.

Note: The co-existence of the above prefixes / suffixes and the implicit
<<seq_operator>> means the following: if an identifier is the same as a
prefix, say the letter r, then ++r"foo"++ is a string literal, but ++r "foo"+
is the identifier +r+ and the string literal +"foo"+ with the implicit
sequence operator in between (the distinction being made in the lexer).
Likewise for suffixes.  It's a wart, but I don't think its a true problem: 1)
style guidelines ensure that the implicit sequence operator is only used when
its rhs and lhs are on separate lines 2) even if they are turned off, its
unlikely that and identifier and a literal are back to back without any blanks
in between 3) even if they are back to back and now truly the wrong thing
happens, it's unlikely that as a indirect consequence another compiler error
occurs.  Note that the same problem also exists with the prefixes being part
of type expression primaries.


[[type_qualifiers]]
=== Type qualifiers

-------------------------------------------------------------------------------
type_qualifier = 'const | 'volatile | 'alignas \< sub_expr \> ;
-------------------------------------------------------------------------------

Notes:

- About placing const objects in ROM:
  http://stackoverflow.com/a/2271055/1306466
 * An const object which's constructor call expression can be evaluated at
   compile time can be placed into ROM.  &To-do* But how about the destructor?
   We must prevent running a ctor which modifies members: 1) only allow const
   objects to be put into ROM which's destructor does not modify members 2)
   allow to elide destructor call -- but I don't see yet a meaningful rule,
   since not calling a destructor is against the core idea of having
   destructors.


=== Expression category taxonomy

Try to make it much simpler than C&plus;&plus;. I hope to get away with only
the types, type qualifiers, object properties already described, and nothing
more.

See <<TCppStd>> 3.10:

- C&plus;&plus;: glvalue -> EF: any data object.
- C&plus;&plus;: lvalue -> EF: an glvalue that is not an xvalue
- C&plus;&plus;: xvalue -> EF: temporaries
- C&plus;&plus;: prvalue -> EF: literals

*to-do*: EF's category taxonomy for: <<temporaries>>, <<literals>>, +this+,
+super+


=== Declaring types / type expressions
----------------------------------------------------------------------
type_def_list_expr = class_type_def_list_expr | enum_type_def | union_type_def | alias_type_def;

generic_pointer_type_expr =
  ## 'normal' (name??? to distinguish from member pointer) pointer
  ['[sub]]#ptrsubtype (\*|'ptrto) type_expr | 
  ## pointer (built-in) to member type
  ['[sub]]#ptrsubtype (\*|'ptrto) type_expr 'in class_type; 

array_type_expr = 
  [array_sub_type] (\[ctconst_expr#n\]|'arrayof ctconst_expr#n) type_expr; 
array_sub_type = 'raw | ...;
----------------------------------------------------------------------

An EF type expression can be read from left to right and the spoken words
correspond exactly to what it technically is.

.Notes
* For simplicity a type name is always a single identifier, e.g. no ``unsigned
  long long''.
* Is it possible that nearly anything by default is signed? Less problems with
  conflicting types.  However some applications really want that MSB.  The std
  library probably cannot have a size() which returns a signed number. 

.To-do
* Add more floating point types, there apparently is also 16bit, 80bit, two
  128bit (112 and 64 mantissa)
* Consider allowing any number of bits for integers.
* Consider user providing means to choose between packed arrays and naturally
  aligned array members?
* Does it really make sense that a type defines its own alignment; that's 1)
  in addition to the declaration of an object 2) the fully expanded type, i.e.
  the resulting type expression, could contain multiple alignas, and EF would
  need to establish rules what the final alignment is.


=== Type aliases

----------------------------------------------------------------------
## At compile-time defines an alias for the given type_expr. At run-time does
## nothing.
type_alias_decl =
  ('newtype|'typealias) new_identifier | ## incomplete type
  ('newtype|'typealias) new_identifier type_expr;
----------------------------------------------------------------------

* ++typealias++: Declares an identifier which is an alias for type_expr, but
  is not a distinct type.
* ++newtype++: Declares an identifier which is a new distinct type.

.To-do:
* Provide ability to define aliases, macros for type_expr, e.g. ++defxx
  ptr_to_array *[]++


=== Type information

When everything is an object, than a type object would have these methods

* +id+
* +name+
 ** For template arguments choose whether template name is meant (e.g. T) or
    the passed type (e.g. myclass)
 ** Same analogous question for typedefs: 
* +sizeof+ is often ctconst, but sometimes (e.g. dynarrays as in C) also only
  known at run-time


=== RTTI

- Classes provide a list of their members as std::tuple.  That way e.g. one
  could implement an reliable (though inefficient) operator= or operator==.
  (Naturally EF already provides those operators)


=== Conversions

[[ways_to_define_cast]]
Conversion from type A to type B can be defined in multiple places:
1) B defines a constructor that expects an A or *A 2) A defines a cast
operator to B 3) There is a global cast operator from A to B.  Semantically
those three are the same single method -- It is an error if a cast from A to B
is defined in multiple ways.  This is a special case of
<<ways_to_define_operator>>.

*to-do*:
- Considering a given member method of class A which accepts a type B (often
  equals A), and now semantically we want that the `same' method also accepts
  a type C.  1) An (implicit) casts can be used to cast C to A and thus the
  existing method can be used 2) An overloaded method is added which directly
  expects B.  How should EF cope with that to reduce ambiguities /
  uncertainties as much as possible?
- How to treat ++A.operator=(*B)++? Shall that also belong to the set of
  methods which as a whole define one single method?  Technically the
  assignment method can not replace any of the other three, but it's still
  very close.  E.g. if a function expects an argument of type A, a type B can
  be passed if there is an ++A.operator=(*B)++.  Maybe the user should have
  the possibility to mark the assignment as explicit, in which case it can
  only be used when explicitly the assignment operator is used.


==== Implicit Conversions
No narrowing implicit conversions, except for to-bool.  Style guidelines
define when implicit to-bool conversion are allowed.  The default is ``never
except when its the top-level operation in the condition of a control flow
construct''.


==== Explicit Conversions

...

=== Misc

Maybe among other ways, provide a format function like shells or Perl offer
it: embed variables directly into the string, prepended with +$+, optionally
curly braces around the identifier.  Look up the ways Perl and Python offer.


[[code_chunks]]
== Code chunks / General Functions

`Code chunk' is a the most generic term standing for all types of function
like things.  What is a better term?  Maybe `general function'?

A procedure does not return any value, while a function does.

=== Properties

Some ideas: 

- <<pure>>
- `const' in the sense of a C&plus;&plus; const method
- constexpr as in C&plus;&plus;11
- final in the sense of a Java final method
- re-entrant
- thread safe
- (pure) virtual


[[function_type]]
=== Function type

The +fun+ list expression introduces describes the details of a function type,
i.e. its sub-types.

----------------------------------------------------------------------
function_type_expr = 'fun naked_fun_type args_close_del;
----------------------------------------------------------------------

Note that since it is part of a type expression, the same keyword +fun+ that
already is used in non-type-expressions can be reused.


=== (Named) Methods

For now same as functions (regarding the definition), just defined within a
class.  Maybe use keyword +meth+ instead of +fun+.  That also makes
documentation more easy.  I.e. terms used in documentation correspond more to
terms used in code / in the syntax of the language.

==== Virtual

Keyword +virtual+ (or +new_virtual+?) to introduce a _new_ virtual method
which does not yet exit in the base class / interfaces with that name and
signature.  This is the default, i.e. +virtual+ can be omitted.

Keyword +override+ to override a virtual method.  It is an error if there is
no virtual method of the same name and signature in the hierarchy.

Keyword +non_virtual+ to declare a method non virtual.  It is an error if a
method of the same name exists in the hierarchy.

Have a keyword (say +force_call_on_override+) for a method which forces
methods overriding this method either need to call it or explicitly say that
they know they don't need to call the super class.  E.g. Java's clone or
finalize methods could need that, probably also methods doing assignments or
testing for equivalence, or Dragon's calibrate method.


==== Final

A +final+ method cannot be overriden by a subclass.  Only applicable to
virtual methods.  Can make the code more performant if the compiler can deduce
the dynamic type and from that can deduce that it is a final method and thus
the virtual table indirection can be omitted.

.Discussion of whether or not final should be provided

Only (?) usable in security related areas, and those should achieve their
goals by other means.  Final is bad for unit testing.  It's bad from the point
of view that the author of class A shall not dictate others how to use it.  On
the other hand it

EF shall not dictate what it is `good' and what is `bad', it only provides
tools which can be good and its up to the user to decide when its appropriate
to use them.

==== FinalAndDelete

For rare cases where you break the ``Liskov substitution principle'' and want
it to make it an error when a virtual method is called.  If the compiler knows
the dynamic type, then it can emit an error if an deleted method is called.
The method should still be implemented, since through polymorphism it
naturally still can be invoked.  If not explicitly implemented maybe the
compiler can generate a default implementation, which e.g. throws.


==== Overload

Only with the +overload+ keyword overloaded methods can be created.  That
shall help guarding against cases where new methods are accidentaly created.

*to-do*: What if I want to overload a method which is not marked as overload
and which I don't have access to?  That problem is probably void if namespaces
can't be reopened as in C&plus;&plus;


==== Force accessing all members

Somehow let the compiler check / enforce that e.g. an assignment operator or
an comparison operators or a toString method accesses all members.  E.g. the
assignment operator needs to write to all members of this, and needs to read
accesses all members of the rhs.  That helps guarding against the case that
when new members are added, accidentaly not all dependent methods are updated.
Provide special statements to acknowledge ``I don't write-to / read-from this
member on purpose''.


=== Declaring / defining (named) functions

The +fun+ list expression defines or declares a new code object of function
type.

----------------------------------------------------------------------
fun_obj_def_expr = 'fun [\(] fun_name naked_fun_type_parameterized \= fun_impl args_close_del;

fun_name = new_identifier | fun_name_operator | fun_name_ctor | fun_name_dtor;

naked_fun_type_parameterized = [type_params] naked_fun_type;

naked_fun_type = (
  ## At most one parameter-list - return-type pair.  Omitting parameter list
  ## defaults to a list of zero parameters.  Omitting the return type defaults
  ## to void (returns `nothing').
  [\: [\( naked_param_list \)] [return_type]]
  ## Multiple throws clauses are allowed, in which case they accumulate
  throws_clause
  ## Multiple modifiers allowed, in which case they accumulate
  'is fun_modifier*
  )*;

param_list = (parameter_decl \,{l?})*;

return_type = type_expr | 'noret;

fun_modifiers = access_modifier | ...;

fun_impl = block_expr | ctor_body | prevent_auto_gen;

access_modifier = 'public | 'protected | 'private;
----------------------------------------------------------------------

The separator preceding / introducing the parameter-list - return-type
argument to the +fun+ list expression is not just an opening parenthesis
because that would raise ambiguities, e.g. when the function name preceding
the parameter-list is actually a macro call.  E.g. in ++fun foo(...)...++, is
++foo(...)++ a macro call which as a whole determines the new function's name,
or is ++(...)++ the parameter list to the new function named ++foo++.

.To-do
- Allow that definition only uses name already introduced by declaration, so
  we don't have to redundantly state signature again.  That fails for
  overloads, but see function name aliases.
- Allow to add aliases to functions.  Both to other name, ignoring signature,
  and to the complete thing (name+signature).
- A lambda is an anonymous function.  That should be visible in some way from
  the syntax.
- What if i want an anonymous function and define signature via an function
  type name?


==== Parameter declaration

----------------------------------------------------------------------
parameter_decl = ['val|'var|'obj] naked_data_obj_decl;
----------------------------------------------------------------------

If the +naked_data_obj_decl+ contains an +initializer+, that is the _default
argument_.


=== Overloaded Operators

A class A can define two methods for a given binary operator and a given
other-operand-type: Where A is the lhs (and the other is the rhs), and vice
versa.  Also, in case the operation is implemented in a commutative way, only
one implementation can be given which is called in either case.

[[ways_to_define_operator]]
A binary operator with class A and B as operands can thus be defined in three
places: in A, in B, globally.  Semantically those three are the same single
method -- it is a compile (or linker?) error if it is defined in multiple
ways.  See also <<ways_to_define_cast>>.

----------------------------------------------------------------------
fun_name_operator =
  'operator (
    'this binary_operator | ## on call site, this is lhs 
    binary_operator 'this | ## on call site, this is rhs
    'this binary_operator 'this | ## commutative implementation
    unary_prefix_postfix_operator 'this | ## unary prefix operator
    unary_prefix_operator 'this | 
    'this unary_prefix_postfix_operator | ## unary postfix operator
    'this unary_postfix_operator
  );
binary_operator = \+ | \* | 'and | ...;
unary_prefix_operator = ...;
unary_postfix_operator = ...;
unary_prefix_postfix_operator = `++ | `-- ;
----------------------------------------------------------------------

See also ``Properties of some standard methods/operators''.


[[code_chunk_call]]
=== Code chunk call

----------------------------------------------------------------------
fun_call_expr = fun_call_target arg_list;
fun_call_target = sub_expr | identifier [type_args];
arg_list = \( ct_list \);
ct_list = (sub_expr \,{l?})*;
----------------------------------------------------------------------

Note that a function call as a whole looks like an <<list_expr>>, but actually
is an operator expression.  Its rhs is an expression delivering an code object, and
its lhs is an argument list.

Style guideline: before the opening parenthesis of a function call there might
not be any white-spaces, at least no vertical white-spaces.  Motivations: 1)
consistent `style' 2) make it unlikely that a programmer wrongly uses
++(...)++ instead ++g(...)++, thus accidentaly programs a function call.  For
consistency reasons, that guideline probably should also apply to the opening
parenthesis of list expressions.


==== Argument passing with key => value pairs
The caller can pass the arguments as ordered list as in most languages.
Additionally each element in such a list can also be a key => value pair, the
key being the name of a parameter which's value is to be set to the value of
the pair.

Notes:

- What is the type of such a key value pair?  How can we differentiate whether
  the caller intends to pass a key value pair as discussed above, or whether
  that pair as a whole is the value to be passed?
- The benefit is that when reading code at caller side, it is more descriptive
  / informative.  However shouldn't it be the task of the IDE to show the
  reader information (type, name, doc) about each parameter of the function
  at hand?
- Parameter names would become half way part of the signature.  If the
  implementation changes a parameter name, some client code might be broken.
- The set of function declarations plus the function definition all had to use
  the same names.  This can be seen as good and as bad.
- What about function pointers?  Can the declaration / definition of a
  function pointer use different parameter names?  After all, the parameter
  names are not really part of the function's signature.
- Also, at least with pedantic name comparison, each caller has to overtake
  the naming style (prefixes, camel case vs underlines, ...) of the method
  implementation.
  * If the comparison rules would leave some controlled leeway, the callers
    could be decoupled from the naming guidelines of the implementation.
  * The caller could provide an internal name and an external name.  Maybe in
    one go where encoded in the name is what is part of prefix/postfix, and
    what is part of the base name
  * But then still, if that base name consists of multiple words, there many
    ways how to exactly `encode' them in an identifier: camel case,
    underlines, ....
  * EF tries anyway to soft enforce a style which is used by everyone.  Here
    it would help again that the implementer side and the client side have the
    same naming styles anyway.


=== Lambdas

An anonymous aka unnamed function.  An unnamed closure which makes no
references to environment.

Maybe since in EF everything is an expression, thus also function definitions,
that already qualifies as lambda.  

--------------------------------------------------
sort(my_collection, fun(a:int,b:int)=a<b$);

## the type of the arguments is known to the compiler because sort expects a
## function with two ints
sort(my_collection, fun(x,y)=x<y$);

## also the names of the parameters can be left away, then the names used
## in the declaration of sort must be used. 
sort(my_collection, fun=a<b$);
--------------------------------------------------

*to-do*:

- Learn D's `lazy evaluation'.  Maybe EF can do something in the same spirit.
  As far as I understand it is `bad' in the sense that at call site it is not
  immediately clear that the expression is lazy evaluated -- but then again,
  EF just provides features, the user has to decide which features he deems
  fit, and balance the pros and cons.


=== Method Lambdas

An unnamed method. 


=== Closures

A closure is any (named or anonymous, does not matter) function which closes
over the environment in which it was defined.  This means that it can access
variables not in its parameter list.  See also
http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda

Can they be templatized?


=== Delegates

Not really a code chunk on its own, but a pointer to one.  See D.


=== Contracts

See D / Ada.  For all types of code chunks.

Pure virtual methods should also be able to have contracts, no?  That includes
interfaces.

Interfaces should also be able to have invariants, no?


=== Overloading

Consider not supporting overloading in EF.

- Together with implicit conversions and namespaces / modules it gets
  difficult to understand which conversions happen and which overloaded method
  is called at the end.  Both for humans and for compilers.
- I like overloading and use it not seldom.  Still it is only convenience, it
  only saves me from having to invent multiple names instead just one name.
  The maintainer also has to know multiple names instead just one, but he has
  (having overloading) also to remember the multiple signatures, so no
  difference for the maintainer.
- On the other side, for constructors we most certainly have overloading
  anyway. 


=== Variadic arguments

Mainly to be compatible to C, to be able to build wrappers around C.  But
shouldn't the wrapper then use a more EF like construct?


=== Properties of some standard methods/operators 

Not only is the code more maintainable since these common operators really do
what humans expect, but also the compiler / analyzer / optimizer ... can
deduce helpful things.

Copy ctor, move ctor, assignment, move assignment have the properties
generally assumed with them.  Const member methods, the copies are equal (see
operator==), .... Thus e.g. a ctor with an initvalue followed by an assignment
can be replaced by a ctor with rhs of assignment as initvalue.

Relation between unary/binary plus/minus, between multiplication and division,
binary operation and assignment and the `corresponding' x= assignment, binary
operators with two distinct types as parameter have 3 methods in
CC&plus;&plus; (member, two global), postfix/prefix increment leave the object
in the same state (i.e. when the return value is not inspected, the compiler
can choose the more efficient).  When a unity object is known, then
&plus;&plus; is equivalent to &plus;&plus;=, same for minus.  That
e.g. helps that ++result = a + b++ could be strength reduced to ++result = a$
result += b++ (the later does not need to create & destroy a temporary).

Can the compiler automatically verify that a user implemented method fulfills
all requirements/rules?  How to explicitly break the rules, if a user really
wants to implement some of these methods specially.  How to enforce standard
types / type qualifiers.  E.g. assignment is a const member methods, expects
an const X& arg, returns an X&.

See also ``Overloaded Operators''.

=== Chaining functions

As in #F with ++|>++ allow to stream output of one function into input of
another function.  Is it possible to have one general solution that also
includes pipes / redirection?  Learn how Windows PowerShell does it.


=== Optimizations

Does it really help if the user has to explicitly state properties such
e.g. pure? After all the compiler can deduce it itself and attach e.g. the
pure property to a function itself internally.  The explicit keyword is
probably only good for humans a) to communicate to a reader that this function
potentially can be used in an efficient manner b) to communicate to the
compiler that it should print an error when the function is not pure
after all.


[[pure]]
==== Pure

See D for pure functions.  In EF, pure can be a property of any code chunk.

Do also a lesser form of `pure' for class member methods: they are as pure
functions but are allowed to read access class members.  When an object is
never modified between such method calls the 2nd call can be omitted by using
the behind-the-scene stored return value of the 1st call.

I think the general version of the above is: when the compiler can detect that
a function call tree does only read from memory that is not modified between
two such calls, then the 2nd call can be ommited by using the behind-the-scene
stored return value of the 1st call.


==== Tail call optimization

...


==== Return value optimization (RVO)

Probably part of the more general copy elision.


== Modules
Do it as in D / Java / Python, have modules, opposed to the concept of C /
C&plus;&plus; with header / source files.  Currently this document uses the
terms `library' and `module' interchangeably.


[[exchanging_module_impl]]
=== Exchanging module implementation
Given a library L1 used by another library L2, and a user module MU using at
least L2, and the user wants to provide his own implementation of L1.

First concrete use case: user can provide an implementation of the memory
management sub-module (malloc, free etc) of the EF standard module.  See
<<memory_management>>.

Note: When compiling module A which imports module B, the resulting object
file for module A can be more efficient if the compiler can look at the
implementation of B.  If A was compiled that way, and thus potentially inlined
some methods of B, and module C uses A (and only has A's object file) and B,
then B can't be exchanged.


[[objects]]
== Objects

[[obj_properties]]
=== Object properties

An object, in EF, is a region of storage with the following compile time
properties:

* _type_
* _value_:      
* [_name_]: A name is optional
* _size_: Is implicitly defined by object's type
* _scope_: 
* _linkage_:
* _alignment_:
* _lock wrapper_ Just an first idea.  See also <<concurrency>>.

[[storage_duration]]
* _storage duration_: Begins after _storage allocation_ (which is before
  constructor call, but not necessarily directly before) and ends just before
  _storage deallocation_ (which is after destructor call, but not necessarily
  directly after).  See also life time.  Members inherit storage duration from
  parent object.
 ** _static_
  *** _system static_: system global, implies shared ownership and implies
      shared access
  *** _process static_: process global, implies shared access.  Const objects
      might be in code segment.
  *** _thread static_: thread private global, implies exclusive access.  Const
      objects might be in code segment.
 ** _automatic_: Informally explained: objects on stack.  That includes
    <<temporaries>> and parameters.
 ** _dynamic_: Informally explained: objects on heap.
 ** _unstored_: An object occupying no storage.  E.g. for certain literals.

* _owner(s)_ / _exclusive/shared ownership_: The owner is responsible for
  freeing the underlying memory resource.  Knowing the owner(s) implicitly
  that defines exclusive / shared ownership: one owner -> exclusive ownership
  / two or more owners -> shared ownership, .
 ** System: 
 ** Process: Implies `shared access by multiple execution threads' (if not,
    why not making it thread local?) 
 ** Thread:
 ** Block/stack: Register is not an owner; its an transparent
    optimization when the optimizer puts an object into an register instead on
    the stack.
  *** Enclosed block on stack:
  *** Enclosed `mini' block on stack: E.g. for temporary objs not assigned to
      observer_ptr.
 ** Owning smart pointer & heap: Only objects on the heap can be owned by
    smart pointers.  Freeing the heap object means passing back ownership of
    the underlying memory region to the memory manager.  So in a way both the
    owning smart pointers and the heap are owner the object.  If the object is
    from a shared heap, then it implies `shared access by multiple execution
    threads'.
 ** Parent object: for member objects
 ** Garbage collector:
 ** User & heap: Only for objects on the heap.  The user must do what normally is the
    job of an owning smart pointer.  See also owner type `owning smart
    pointer'.

* _allowed observer_: Describes the allowed observers of the object.  Each
  owner is also an observer, but there are potentially additionally also
  non-owning observers (being only(?) non-owning pointers).
 ** _exclusive/shared observability_: exclusive observability -> at most one
    observer allowed.  shared observability -> two or more observer allowed.
    The compiler must ensure that the (last remaining) owner does not free an
    object which still has other observers.  See also `current observers'.
 ** __``execution thread(s) having observers''__ / _mutual exclusion required_
    / _time shared_ / _exclusive / shared access_ (observers being in
    different ``threads of execution''): If all the observers are in one
    execution thread, or if none of the observers makes write access, then no
    mutual exclusion is needed.  Otherwise the object needs some form of
    mutual exclusion.  ``execution thread'' is meant to be an umbrella term
    for thread, process, ISRs, .... *To-do:* 1) What exactly does `to be in'
    mean when saying 'an observer is in execution thread ...'

An object has additionally the following run time property:

[[life_time]]
* _life time_: See also storage duration.  From the C&plus;&plus; standard:
  3.8 Object Lifetime: 1/The lifetime of an object is a runtime property of
  the object.  The lifetime of an object of type T begins when: — storage with
  the proper alignment and size for type T is obtained, and — if T is a class
  type with a non-trivial constructor (12.1), the constructor call has
  completed.  The lifetime of an object of type T ends when: — if T is a class
  type with a non-trivial destructor (12.4), the destructor call starts, or —
  the storage which the object occupies is reused or released.
 ** _storage reuse_: As in C&plus;&plus, allow to end the life time explicitly
    by calling the destructor explicitly, without ending the storage duration.
    I.e. the storage can be reused with an appropriate constructor.
 ** Construction of objects with static storage duration:
  *** Initializer is a constexpr: no issues
  *** Initializer is not a constexpr: *to-do*: how to ensure that there are no
      circular dependencies which result in accessing not-yet-initialized
      objects?  E.g. only using pure functions and/or statics earlier in the
      file.  imports are sub-divided into proper imports and `weak' imports
      which are used to break circular import dependencies.
  *** Initializer is not a const sub_expr and its about an object with static
      storage duration in local scope: constructor is called the first time
      the flow of execution reached the point of declaration.  *to-do* make
      visible that at run time there is a check needed whether the init is
      already done, which involves a hidden object.  *to-do* with self
      modifying code that cost could be reduced to zero

* _current observers_: Determined by compiler at compile time.  The owner can
  (checked by compiler) only free an object if no observer beside the owner
  remains.  (or more specifically, if no observer actually observes / accesses
  the object after the deletion). See also `allowed observers'.

*to-do*:

- Study http://bartoszmilewski.com/category/d-programming-language/page/2/
- Is a literal an object?  If so, what are its properties according to the
  above?  In C&plus;&plus; its an prvalue, see <<TCppStd>> 3.10.  
  * How about making it a const object in either process or thread
    global storage.  However for most cases, in particular fundamental types,
    the compiler and linker are expected to optimize away any real storage
    allocation apart from within code segment.
  * How about a new storage duration ``unstored''?  Fundamental types can be
    copy constructed with their literals (with a constructor which has no
    formal signature -- here we take advantage of it being a built-in
    type). You can't take the address of it, for that you need to create a
    temporary, either explicitly or implicitely.
    ** How about collection literals: strings, ct_list, ...? _unless_ the
       target architecture allows it, they can't be `inline' in the code
       segment, so they must be in the (const) data segment and thus could be
       treated has having storage.
- What is the result of the address-of operator?  How about making it a
  (const) temporary.  That would be consistent with the mental image that all
  operators return their result as a temporary.  For C&plus;&plus; see
  <<TCppStd>> 5.3.1/3.


[[obj_decl_def]]
=== Declaration / definition
Type, storage, linkage, alignment can be defined as following:

----------------------------------------------------------------------
obj_def_list_expr = data_obj_def_list_expr | fun_obj_def_expr;
obj_def_op_expr = data_obj_def_op_expr;

obj_prop_expr = type_expr [storage linkage alignment scope]#*any order*#;
storage = 'static_storage | 'thread_storage | 'auto_storage;
linkage = 'extern | 'intern;
alignment = 'alignas \( (sub_expr#integral|type_expr) \);
scope = 'block_scope | 'full_expr_scope;
----------------------------------------------------------------------

.To-do
* Is alignment part of object definition or of type_expr?


=== Layout

- Don't have C&plus;&plus;'s restriction that each obj must have an unique
  address.  Or just allow for zero sized objects, in particular zero sized
  arrays.  
- +alignof+
- bit fields
- pack as attribute to structs/classes


=== Object class

- +bytes+ or +storage_size+ member to access objects size in multiples of
  +byte+.  Don't use +size+, since that is confusing with +size+ used by
  collections.


[[local_object]]
=== Local objects

<<storage_duration>> is automatic.  Scope is the enclosing block.


[[local_object_def]]
==== Definition

A bit simplified, the ++obj++ family of list expressions allocate local
storage for the object, initialize (aka construct) it with the given
initializer, bind the given identifier as name to it and finally return a
`reference' (*to-do*: There are no references in EF, so what exactly is
returned?) to the new object.  Allocated storage (and thus indirectly also the
object), has an associated block being the owner, see <<associated_block>>

There is also analogous form to define multiple local data objects.  It
returns a list of `references' (*to-do*: same point as in previous paragraph)
to the defined data objects.  Also here the list of identifiers can omit
naming certain elements of the list.  Note that thus a trailing comma means
that the last element of the list is unnamed -- i.e. a trailing comma does has
an effect.  (*to-do*: reconsider that and force to always state a token.  A
special token, e.g. +none+ could be used to mean `unnamed' identifier. But
then again especially for lambdas, unnamed object in a concise syntax can be
convenient -- as so often, leave the decision to the user via style
guidelines).

----------------------------------------------------------------------
data_obj_def_list_expr =
  ('val|'var|'obj)
  naked_data_obj_decl
  args_close_del |

  ('vals|'vars|'objs)
  (new_identifier [initializer] \,{l0})*
  ( \: type_expr
    'is data_obj_modifier*
  )*
  [\= sub_expr]
  args_close_del; 

naked_data_obj_decl = 
  new_identifier#name
  ( initializer |
    \: type_expr |
    'is data_obj_modifier* 
  )*;

data_obj_def_op_expr =
  new_nonempty_identifier#name ( `:= | `:&= ) sub_expr#initializer;
----------------------------------------------------------------------

The earliest lexical point the name can be used is the next standalone
expression of the enclosing standalone expression sequence.


*to-do*:

- As with function declaration, omitting the name to create an unnamed object,
  but still using the ++\(...\)++ initializer results in ++val(...)$++, which
  is an ambiguity to the list expression syntax variant ++val(...)++.


[[initialization]]
==== Initialization (aka construction)

The syntax to initialize a data object is always is composed of the following
+initializer+ rule.  I.e. the equal sign is an argument separator of the
enclosing expression list, and it introduces an argument being an initializer.

----------------------------------------------------------------------
initializer = \= (
  arg_list |
  sub_expr | ## short for "(sub_expr)"
  'nop_init | 'laterctor);
----------------------------------------------------------------------

Note that the opening parenthesis can not be an alternate argument separator,
beside the equal sign, also introducing an initializer argument, due to
ambiguities.  In EF macro calls can occur nearly everywhere, so opening
parenthesis are in most cases for `calls' of any sort.


===== Uninitialized / not-yet-constructed data objects

EF supports the ability to `initialize' a data object by doing nothing with
the ++nop_init++ keyword initializer.  In contrast to C, in EF one has to be
explicit about his intend to not properly initialize a data object.  Such an
data object is considered to be initialized (aka constructed), thus its
<<life_time>> has started.  ++nop_init++ is useful for cases where the
compiler cannot detect whether the data object is initialized later (in which
case +laterctor+ could be used), but the programmer is sure he does the right
thing.  Also ++nop_init++ holds on to the premise of EF that you can do all
the nasty things in EF that you can do in C provided you're explicit (and
additionally provided you explicitly turned off guidelines which prohibit
using `nasty' constructs).

EF also supports saying (with the +laterctor+ keyword / initializer) that
everything as normal is done (most notably storage is acquired), just the
constructor is not yet called.  The <<life_time>> does not begin until the
data object is initialized (aka constructed) via an write access.  Some
consequences: 1) the first assignment really is a constructor call with
exactly one argument 2) the compiler must not call the destructor if the
constructor has not been called 3) that leads to the want to be able to
explicitly exclusively call the constructor, without the storage allocation
part. 

**To-do:**
- Is +laterctor+ really needed if there was a rule that data objects need to
  be write accessed before one is allowed to read access them?


===== Guaranteeing initialization
Sometimes one desires to initialize a variable with something other than the
return value of an expression.  E.g. via an out parameter of a function
(i.e. passing the new not yet initialized object and let it be initialized by
the function).  Or each clause in a conditional flow control expression
wants to define somewhere the initializer.

Keywords that promise that a function will init an outparameter -- write to it
at least once before reading from it.

Keywords in a flow control expression that promise that a given object will be
initialized -- written to it at least once before reading from it.  That also
would be a use case for the the example that a flow control expression as a
whole returns already the desired initializer, but the when its a long
multiline flow control expression, then ++var i : int = if ....$$++ may look
awkward (on the other side that's just a matter of taste, which is also a
matter of being used to such constructs).

**To-do:** In case of the +laterinit+ initializer.  The flow control
expression's clauses can not call assignment but must call the ctor?  Not if
the class promises that (ctor with laterinit/nop_init followed by assignment)
and (normal ctor with initvalue) are equivalent.  Or the rules of EF just say
that the assignment really calls the ctor.  Or there is a syntax to just call
the ctor for an object -- without allocating the storage, since that already
has been done.

**Mind:** Let the computer automatically deduce non-initialized variables where
possible.  Do not force to user to state things the compiler can deduce
itself -- except where it helps to communicate intend.


==== (Explicit) destruction
Allow to explicitly exclusively call the destructor.  That ends the life time
of the data object, but does not yet free the storage behind the data object.
That implies that the compiler 1) must check that the data object is not
accessed anymore after its destruction 2) does not call the destructor again.


[[associated_block]]
==== Associated block
This chapter is about which block is associated to a given storage, which
includes the object owned by the storage.  See also <<block>> and
<<local_object_def>>.

Each node in the expression tree has a default block associated to it.
Certain nodes create a new block, and most probably their children have that
block associated to it (but not necessarily form a very general point of
view).  At top level, it's the `module init function' which is run at
start up.  By style guideline no local variables are allowed.  The class def
node opens a new block, to which no locals may be associated to.  Function
body nodes open a new block.  Flow control list expressions at their top level
open a block.  The `block_expr' argument to a flow control list expression
naturally opens a block.  By default style guideline, certain nodes define
that there is no current block, and no blocks may be opened in the sub-tree.
As the class example, there is the variant that a node defines that there
currently is no current block, but blocks might be opened (but only if `open
block node' is something call-able.  E.g if in the body of a class just
explicitly a block is opened, that is not callable).

Make it possible that all clauses of a flow control expression can introduce
an object which is associated to an outer block.

Give the user the possibility to choose the associated block also for
variables defined in conditions of a flow control expressions.  For example
a) only the condition b) additionally also one clause associated to the
condition c) additionally all following condition-clause pairs of the same
flow control expression d) the block associated to the object is the outer
block of the flow control expression.


==== Scope
Explicit scopes can be created using a list expression, say ++scope...$++.
That would be roughly equivalent to C's ++{...}++.


==== To-do
* Define where _exactly_ lifetime and scope begin.  In particular with
  collection initializers: Can one element refer to another one? Does that
  depend on whether the referee was already initialized itself or can you get
  a reference/pointer to a not yet constructed element (that would probably be
  nice to conveniently construct trees).  Can you refer to the collections
  size of the initializer? That also could be useful.
* Try to get rid of : or of obj keyword.  Only having : would be a bit closer
  to the idea that in EF there are only expressions, i.e. only operators.  It
  would also be shorter.
* Try to have the identifier on the lhs and the obj_prop_expr on the lhs.
  Would be closer to the way other declarations and definitions are done
  in EF.  Also I feel the identifier more important as the type -- the type is
  mostly for the compiler for the static type system; in other languages there
  is no type information at all.  This way the identifiers would also be
  aligned, e.g. in class definition.
* Make local objects const by default.  I.e. the +const+ qualifier is
  implicitly prepended to the obj_prop_expr.  Naturally non-const local
  objects must be possible.  It's just that const objects should be the norm
  and to achieve that they should have the easier nicer syntax.  Reasoning:
 ** One thing should only have one responsibility
 ** Is in favor of functional programming where variables are tried to be
    avoided.
* allow to explicitly shadow a name declared in the same scope and/or to pop
  the latest automatic variable from the stack.
* Concerning objects declared in the condition of a flow control expression:
  let the user choose whether he want's the scope to be limited to the
  enclosing block (default, would be one single consistent rule), or whether
  the scope ends at the end of the flow control expression.  Specially with
  the for loop, the iterator variable sometimes is wanted to vanish after the
  loop, sometimes to vanish not until the end of the enclosing loop.  Or
  extend the concept to scope the variable to the enclosing full expression.


[[temporaries]]
=== Temporaries
A _temporary_ is the unnamed data object returned by an non-void (sub-)
expression.

It's not clear yet how to define the storage duration of temporaries.
Possibilities:

* The storage duration of a temporary ends after evaluating a
  <<standalone_expression>> (hence the alternative name ``mini block
  expression'').  That allows that an expression can take a pointer to a
  temporary as argument, possibly modify it, and return a pointer to it, and
  that pointer can be used as argument to an outer expression.
* The storage duration ends after the parent in the expression tree is
  finished.

It's not clear what the exact object properties shall be:

* Shall a temporary be const as in C?  From a very general point of view,
  const (aka immutable) objects are easier to work with than mutable ones.
  Also regarding concurrency.  With objects on stack concurrency is seldom an
  issue since such objects very seldom are accessed by multiple threads.  I
  think I find it better to make temporaries mutable.  Then a temporary can be
  passed as mutable argument to a function -- for most cases that makes no
  sense since after the function returns nobody has access to the modified
  temporary.  (*to-do*: Examples where that could be useful).  Or make it
  const, and the user can explicitly `cast' that object (without creating
  another object) to non-const.  That would also be closer to the principle
  that most things in EF are const by default. 


==== Make local
There is the idea to provide a feature with witch storage duration can be
defined local (instead standalone expression).  Or in other words, define that
the object is not a temporary but an unnamed `normal' local object.  That
would be similar to what C&plus;&plus; can do when you bind a temporary to a
const reference.

It's not yet clear by what means.  For example:

* A unary prefix operator ++make_local++ / +ml+, which defines that its
  argument shall be an unnamed local object instead a temporary.  Possibly,
  similar to definition of local objects, with further arguments define the
  exact block which shall be the owner.  The rules for when and how storage is
  allocated on the stack is the same as for <<local_object_def>>.
* Note: Using +val+/+var+ without providing a name does not work because that
  would create a _new_ local object, tough unnamed, which is (copy-)
  initialized by the temporary.

However `make local' might be a feature with diminishing returns.  The benefit
is that, in case you need that object at more places in your block than just
one single place in the expression tree, you don't have to copy it to a local
object.  However other concept already help to mitigate such costs: RVO, move
semantics, the ability to create local objects virtually everywhere since
everything is an expression. 


[[variable_sized_obj]]
=== Variable sized object
If variable sized raw arrays are allowed as members, then the whole object
becomes variable sized.

An raw array of variable sized objects is not possible.  Thus probably the
object size is like a template argument.  But its not really another type
-- thus that apparently calls for a new type concept: each template argument
has as attribute, whether it contributes to defining distinct type or not.
See <<templates>>.


[[class]]
== Classes

=== Defining
----------------------------------------------------------------------
## At compile-time define a new class type. At run-time does nothing.
class_type_def_list_expr = ('class|'interface) identifier#name [type_params]
  [\: super_class_list] ['is class_modifier*] \= block_expr#body args_close_del;
super_class_list = ( ['public|'protected|'private] class_type_expr \,{l?} )*;
class_modifier = ... ;
----------------------------------------------------------------------

Only single inheritance, no multiple inheritance, but implementing of an
arbitrary amount of interfaces.

*to-do*:

* Proper naming.  E.g. `general class' for the general class concept, and
  `proper class' (or `strict class'), `interface' and `struct' for
  specializations of that generic concept.


=== Referencing 

--------------------------------------------------
class_type_expr = identifier#*class' name*# [type_args];
--------------------------------------------------


=== Special methods

[[constructor]]
==== Constructor

----------------------------------------------------------------------
fun_name_ctor = 'this | 'ctor | 'constructor;
ctor_body = [member_init_part] [classic_ctor_part];
member_init_part = block_expr | 'this initializer;
classic_ctor_part = mi_end_expr block_expr;
mi_end_expr = 'mi_end; ## of type void
----------------------------------------------------------------------

The constructor body is composed of two parts: 1) the member initialization
part, which's responsibility is to construct all members 2) the classic
constructor part, which does additional things.

At the beginning of the _member initialization part_ all members are
+laterctor+ `initialized', see <<initialization>>.  A program that read
accesses a member before it initializes that member is not well formed.  The
implementation is not required to print a diagnostic message.  Probably that
it is difficult for a compiler to do a correct verification for all possible
cases, including any function call etc.  Define a set of cases which the
compiler is required to detect (e.g. in case there no flow control constructs
and no calls).  At the end of the member initialization part, any not yet
constructed member is automatically constructed using the initializer of the
declaration of that member; for the super class that's the default
constructor.  A _delegating member initialization part_ does delegate the work
of initializing the members to another constructor of the class.  That is done
by initializing the `member' this with ++'this initializer++.  This expression
may only appear in the member initialization part, and if it does, no other
expressions might be in the member initialization part.

When the _classic constructor part_ is entered, all members are initialized.
The classic constructor part is preceded by the expression ++mi_end++, which
initializes all members not yet initialized by the preceding member
initialization part.  +mi_end+ is only allowed to appear in a constructor
body, and at most one time.  Since normally the member initialization part is
preferred over the classic construction part, it's the classic constructor
part which has the burden of being a bit more cumbersome to define.

If an exception occurs, all, and only those, constructed members are
destructed.

_Member alist constructor_: Provide a auto generated constructor, which
optionally can be made member of a class, which allows to construct an object
by giving an association list (member name -> (init value |
constructor)). Member name can be also ++*++ (or ++rest++) to refer to all not
explicitly stated members.  The member name ++super++ is used to construct the
super object if any.  This is probably particularly useful for structs.  Style
guideline prohibit to make use of that constructor when there are any
non-public fields.


*to-do:*

- How to call the constructor explicitly?  E.g. for already allocated but not
  yet constructed objects.  E.g. due to use of some `non-standard' +new+
  construct, or due to the +laterctor+ initializer.
- The code shall be required to explicitly state which one of these sub-types
  a constructor is: copy constructor, move constructor, cast (copy)
  constructor, cast move constructor, or other.  See also <<assignment>> which
  has a similar requirement.
- How to allow that when a member is never read accessed between construction
  and one or more write access (which completely replace the object), that
  only the last write access can be made the one single construction.  Maybe
  that is a concept that should be applied anywhere, not just in constructor
  bodies.
- Decide on the constructor name.  Using something explicit like +constructor+
  most probably will result in less ambiguities as when using e.g. +this+.
  Mind also getting the address of a constructor or explicitly calling a
  constructor.  
- What is D's init?  Why not just use default ctor?
- Make cast constructors explicit by default, i.e. they only can be called
  explicitly, not implicitely.  If you want an implicitly call-able cast
  constructor, you have to explicitly declare it as such.


==== Destructor
 
----------------------------------------------------------------------
fun_name_dtor = `~this | 'dtor | 'destructor;
----------------------------------------------------------------------

How to call the destructor explicitly? 


[[assignment]]
==== Assignment operator

*to-do*:

- The code shall be required to explicitly state which of these sub-types an
  assignment is: copy assignment, move assignment, cast (copy) assignment,
  cast move assignment, other.  See also <<constructor>> which has a similar
  requirement.  See also <<ways_to_define_cast>> for cases where the
  assignment indirectly allows an lhs of another type.
- Make `cast assignments' explicit by default, i.e. they only can be called
  explicitly, not implicitely.  If you want an implicitly call-able `cast
  assignment', you have to explicitly declare it as such.


[[swap]]
==== Swap

By style guideline, it must provide the strong exception guarantee.


==== The big five
By style guideline, either none or all of the big five have to be defined.
They are copy constructor, move constructor, assignment, swap, destructor.


=== Automatic generated methods
Somehow differentiate between ``there is an automatic generated method
available, but not yet declared as being member of the class'' and ``the
actual default ctor / assignment operator / ... that really is defined as
member method, and its implementation says that its implemented in terms of
the automatically generated one''.  Probably the following is even more
general: The automatically generated methods are private and have a special
name, e.g. the regular name with a +auto_impl+ suffix or prefix.  They can
then be used as normal methods.  That has e.g. the advantage, that say the
equality operator can have a custom implementation, which somewhere in its
body calls the automatic generated method.

Probably only the default constructor and the destructor should automatically
be implemented using the automatically generated implementation.  All others
need to explicitly be declared if the user wants them as members of the class.

- Default constructor
- Copy constructor
- Move constructor
- Destructor
- Assignment operator
- Equality operator
- All other comparisons operators, given an implementation of {++\<\=>++} or
  {one of {++==++, ++!=++} and one of {++\<=++, ++<++, ++>++, ++>=++}}.  See
  also the D programming language.
- friend swap function


[[prevent_auto_gen_of_method]]
==== Prevent automatic generation of a method
Depending on the names and the access specifier of the automatic generated
methods, the need to prevent automatic generation might be small enough to not
provide a `prevent automatic generation of a method' feature.  E.g. if they
are all private and have a special name which is certainly not referred to by
mistake.

Variant 1) The `implementation' in a method definition is a keyword.  For
convenience, also give a short whatever to delete a group for often occurring
use-cases.

----------------------------------------------------------------------
prevent_auto_gen = 'delete;
----------------------------------------------------------------------

Variant 2) Have a new access specifier ++none++.  Put method `declarations'
there.  To me that is closer to what actually happens as `defining' a method
and in either of the public / protected / private access section and in the
body say that the implementation is `++delete++d'.


*to-do*

- Actually each of the above methods comes in multiple variants.  The
  arguments can be one of 1) T 2) & const T 3) & volatile T.  The user shall
  have the authority to decide which ones are auto implemented.


=== Friend

Unlike D, keep +friend+.  I don't like D's solution that within a module there
is no private anymore.  In my eyes private also protects myself / the
maintainers from making mistakes in one single module.  E.g. sometimes
redundancy sadly is needed, and then I want to encapsulate that redundancy in
an very small area, i.e. a very small helper class.


=== Methods / Operators

See chapter <<code_chunks>>.


=== Members / Properties

- See D.  However EF lets you default implement properties.
- In the declaration of a member, one can state whether and what
  gutters/setters are (auto) generated [mind the different access].  The
  implementation is automatic or user given.


=== Invariants

See D


=== Const classes

Classes can be `tagged' +const+ (aka immutable).  Apart from the constructor
and the destructor, all members must be const.  Motivation: 1) Helps
communicating intend 2) Helps that not accidentaly a member is ever non-const.

Should the compiler complain if an non-const object is created of a const
class?  It's not an error, is just somewhat senseless.  But if it did
complain, it also means to break client code if a so far non-const class is
made const.


=== Abstract classes

A class can be `tagged' +abstract+.  It is a compile error if a class tagged
abstract has no abstract methods, or if a class not tagged abstract has
abstract methods.  Motivation: Helps communicating intend -- the user has not
to lookout for any abstract method.

=== Support composition and or / mixins

Composition could e.g. by supported by enforcing that the `Decorator' class
invokes all public methods of the `wrapped' class, i.e. that no public method
of the `wrapper' class is not accidentaly not invoked.


=== Packed

...


=== Pure OO / OO pureness

Also built-in types, but without sacrificing being as close to HW as C.
normal objects, functions, modules, ...

Does it help when there is a common base class as in Java?


=== Structs

An EF struct is a class that is as slim as a struct in C.  No virtual methods
since they require a virtual table pointer in the object.  No destructor since
that requires invoking it at the right time which is a cost that is not
directly explicitly visible.

However allows for non-virtual methods, since they don't cost more than global
functions, apart from passing the implicit +this+ argument.  Calling a member
method is more less clearly distinguishable from calling a global method, so
this cost is pretty good visible at call site.  Also allow for class static
methods.

Also allows inheritance, which in absence of any virtual method is technically
the same as just have a normal member (++struct D extends B = $++ is
technically nearly the same as ++struct D = var B foo$$++).

As in C&plus;&plus; the default access modifier is +public+.

*to-do*:

* What about auto generated methods, such as default constructor or
  assignment?  In any case prevent the case that a method is generated per
  struct type.  If the compiler can be forced to use one single generic method
  for all default struct assignment operators (probably memcopy based), it
  could be allowed.


== Control flow

----------------------------------------------------------------------
flow_control_list_expr = conditional_expr | loop_expr;
flow_control_op_expr = jump_expr | other_control_flow_expr;

conditional_expr = if_expr | givenchain_expr | jumptable_expr |
  'unless [\(] sa_expr (\,|'do) block_expr (\)|'end);

if_expr =
  'if [\(] sa_expr#condition [\:|'then] block_expr#body
  ('elif sa_expr#condition [\:|'then] block_expr#body)*
  ['else block_expr#body]
  args_close_del;

givenchain_expr =
  ## the optional 2nd expression is a predicate function object which defaults
  ## to test for equality.
  'given sa_expr [\:] 
  ('when \( expr_list#*at least one*# \) block_expr_opt_falltrough)* 
  ['else block_expr]

jumptable_expr =
  'jumptable sa_expr
  ('when \( expr_list#*at least one*# \) block_expr_opt_falltrough)* 
  ['else block_expr]  
  args_close_del;

loop_expr =
  ## to-do 
  ## - Provide something ala "foreach ( key,val in mymap )". Maybe that works
  ##   if mymap returns a built-in list of fixed size, so it can be assigned
  ##   to the ``list of fixed sized'' key,val.
  ## - like in ?? a nested loop in one written loop "multiforeach ( i,j in
  ##   matrixindicies )" However that gets difficult with jumps
  ##   (break,continue,...). To which loop do they refer?  Probably a feature
  ##   with dimishing returns.
  ## - ['begin sub_expr] 'while sa_expr 'inc sub_expr 'do sub_expr | what does ruby, python,
  ##   scala, ... do?
  ## - alternatively: integralexpr.times(closureexpr)
  'foreach [\(] sa_expr [\:|'in] sa_expr [\:\|'do]
  block_expr#body
  args_close_del |

  ['for|'loop] [\(] standalone_expr_seq#init \, sub_expr#condition \, standalone_expr_seq#inc [\:|'do]
  block_expr#body
  args_close_del |

  ('while|'until) [\(] sa_expr#condition [\:|'do]
  block_expr#body
  args_close_del |

  'do [\(]
  block_expr#body
  ('while|'until) sa_expr#condition
  args_close_del;

## jumps. The result type of control flow jump operands is typically
## noret. See also labelled_sa_expr.
## to-do: as in Perl, jump to specific loops. Also relative numbers to
## identify nested enclosing loop
jump_expr = 
  'ret sub_expr | ## returns from enclosing code chunk
  ('goto | 'continue | 'redo | 'break) [label_expr] |
  ## defines the enclosing/referred loop expression's value
  'breakwith sub_expr; 

other_control_flow_expr = 
  ## to-do: what is the metatype and type of this expressions?
  'label identifier;
----------------------------------------------------------------------

.Notes
* Short circuit operators such as +or+ or +and+ are also kind of flow control.

.To-do
* As for block_expr, make it a compile time switch whether parentheses are
  enforced for the conditional part of the flow control expressions.


=== Interact with other programs

However mind that not on all platforms you can `execute a program by stating
its path'.  On many embedded systems there is no file system.  Maybe make the
pipes / redirections a more abstract level: something similar to C&plus;&plus;
streams.  Just an easy syntax to connect streams to each other.


=== Redirection / Pipes

Make it easy to interact with other programs using pipes and redirection, like
shell scripts do it.  See also chapter "chaining functions". 


== Ranges

...


== Slices

As in Python/Ruby, easily transform a collection to another collection, or
interpret a collection as another collection.


[[resource_management]]
== Resource management: RAII / GC

Basic idea is to do resource management via RAII as in C&plus;&plus;.  EF
tries to have cheap destructor `calls' by trying to avoid them all-together.
Optionally, simultaneously, also garbage collection is provided for heap
memory.


*to-do*:

* How to prevent that non-returning methods leave no resource leaks behind,
  since destructors of locals are not called.

[[cheap_destructors]]
=== Destructors & how to try to make them cheap

- Lazy destructors (or resource freeing in general) for objects on heap by
  default (that includes `dtors' of smart pointers).  Normal constructors only
  for RAII classes where the resource really must be freed upon destruction of
  the host object.  Customizeable by providing implementations of the
  primitive functions which replace the default implementations
  (++push(__ctor_addr__)++). As in a garbage collector there will be `cleanup'
  rounds.  An _ordered_(!) set of `root' ctors has to be called, which then
  potentially call a tree of further ctors.  A round's run-time can be reduced
  e.g. by partial `collection': stop calling ctors somewhere in the middle.
  * Besides ctor, also e.g. assignment (e.g. to unique ptr) frees the current
    resource owned by the unique smart pointer.
  * Give the user the control whether he wants to do the resource freeing lazy
    or greedy.  The default is that the compiler is allowed to choose what it
    sees fit.
  * +delete+ (or +free+) operator (in lazy and greedy variant) as more
    expressive variant to the equivalent ++= null++.

- Nonexistent destructor: Classes not owning resources, and only having
  objects of such classes as members, need no destructor at all.  Thus no
  destructor needs to be called.  *to-do:* How to arrange that mostly
  non-owning smart pointers can be used, and only seldom owning
  smart-pointers?  Probably it helps if variable sized objects (i.e. most
  probably arrays) are allowed at least on stack, but also as members.

- Try to reduce each destructor to a list addresses of heap objects which need to
  be freed (in any order, without any further ctor code) in one go.  I.e. try
  that the only code the body of a destructor executes is adding a set of
  addresses to the global to-be-freed list.  No dtors of member objects; that
  already has been `inlined' in the list previously talked about.
  * `lazy free' on most occasions, e.g. internally in owning smart pointers, an
    object on the heap is `freed' by just pushing it's address on the
    to-be-freed stack.  Also null can be pushed for simplicity at caller side
    (there is a huge amount of call sides, but only one (or very few) sides
    where the to-be-freed stack is walked through to actually free the
    objects.  *to-do*: Apparently the kernel can automatically grow the stack.
    Can I use a similar feature for the stack of to-be-freed addresses?
  * is it possible to reduce a ctor call to simply pushing a list of heap
    address also in the case of e.g. a linked list where the list objects has a
    smart pointer owning the head node, and each node has a smart pointer
    owning the next node?

- Allocation on stack instead heap, the return type being an non-owning
  pointer.  What can I do such that allocation is transparent, i.e. caller
  does not know whether it allocates on stack or heap?  E.g. consider a
  `normal' local object on the heap which is referenced only by that single
  `normal' local identifier (possibly additionally read only references). When
  it internally wants to allocate objects and wants to be the unique owner of
  them, they can be created on the stack.  The parent object would then not be
  really the owner, and it's dtor could be empty.
  * Will result in a `new'(?) way of stack frames.  After a call, the stack
    will still contain the newly allocated objects within the call.
  * The corresponding free call to such an allocate call will not do anything,
    since the owner is not the caller but the stack.

- When considering costs: Also a `perfect' C program has to pay for things, it
  also has to call malloc/free, do error checking by comparing return values
  and depending on the result do a branch.  So a `perfect' EF program does not
  pay for anything at run time that not absolutely has to be done in any case
  anyway.


[[memory_management]]
=== Memory management

* Since EF can somewhat control where pointers point to, it might sometimes be
  possible to move an object in memory.  That can e.g. help within the heap,
  e.g. to release (to the OS, on linux via (s)brk or (anonymous) mmap) `large'
  amounts of free memory which only can be released thanks to moving `a few'
  objects within it.  In a more general sense: the heap manager can fight
  defragmentation better if it can move objects.


[[memory_management_primitives]]
==== Manual memory management primitives / storage allocators

----------------------------------------------------------------------
memory_mgmt_list_expr =
  ('new | 'raw_new) [\(] type_expr initializer args_close_del |
  'raw_delete [\(] sub_expr args_close_del;
----------------------------------------------------------------------

+new+ creates a new data object, internally using +raw_new+, and returns an
<<unique_ptr>> to it.  Meant to be equivalent to C&plus;&plus;'s
+make_unique+.

+raw_new+ creates a new data object and returns a <<raw_ptr>> to it.  Standard
style guidelines disallow its use.  If an exception occurs, call destructor
for all members which's constructor finished, and free the storage allocated
in step 1:

1. Allocate storage (*to-do*: using which storage allocator exactly?) to hold data
   object
2. Call constructor of data object, passing it the given arguments

+raw_delete+ deletes an data object created with +raw_new+.  Standard style
guidelines disallow its use.

1. call destructor of data object
2. free storage (*to-do*: using which storage allocator exactly?)
3. Set it's argument to null if its an lvalue (that means the're effectively
   two delete versions).  If you don't want to pay the cost of nullyfing your
   lvalue arg, cast it to a non-lvalue.

Support custom memory management primitives, i.e. user shall be able to
provide its own version of new (aka malloc), delete etc.  The current idea is
that the memory management sub-module of the EF standard module can be
implemented by the user.  See <<exchanging_module_impl>>

Make allocation on heap and stack such that optimizers have some leeway to
choose whether in reality it is on stack or on heap.  Probably it'll be
somewhat like: have one form to define allocation of a new object in a syntax
similar to C.  To define an object to be allocated somewhere, create a
(built-in) smart pointer with built-in keywords/syntax, e.g. similar to
C&plus;&plus; ++make_unique++, just hopefully shorter.

Mind concurrency.  Consider having malloc/free in two versions: once for heap
objects owned by only one thread, and once for shared heap objects.  In
anyway, the memory management primitives must be reentrant (also the one
thread private heap malloc method might be called simultaneously from different
threads).

Allow that each thread has it's own private heap.  Memory allocation
primitives on the thread private heap don't need mutual exclusion protection.
Naturally there is also the `traditional' heap which is shared among threads.
Modifying the shared heap requires mutual exclusion which naturally has some
non-zero costs.  The intention is to use the shared heap only for objects
which need shared ownership.  If you only need shared access to an object (but
have an exclusive ownership), a thread private heap also works. 

There is _no placement new_ as in C&plus;&plus; ... *to-do*: describe EF's way
of separating allocating / freeing storage and of constructing/destructing
objects within storage.

There is _no array variant_ of +new+ and +delete+ (as there is e.g. in
C&plus;&plus;), since the all array types handle construction and destruction
of their members by themselves.

*to-do*:

* Provide allign argument to new?  In most cases alignment is a property of
  the type, so it can be deduced from there. 
* Find out more about batch malloc & free.  Would it help if EF would try to
  favor batch free over a loop with normal frees.
* Read http://en.wikipedia.org/wiki/Manual_memory_management and follow the
  links at the bottom.


==== Memory model and object layout in memory

- Allow zero sized objects (which then also makes zero sized arrays more
  feasible).  Most probably that means that the `costs' of this decision are
  that `multiple' such objects really are identical, i.e. there is really only
  one object which has different names.
- +alignof+
- bit fields
- pack as attribute to structs/classes


[[smart_pointers]]
== Built-in (smart) pointers

Classifications / abstract base types:

owning pointer::  All of the owning pointers have two variants: 1) to single
  object 2) to array of same size/type objects.  This is needed in order the
  correct delete operator (delete vs delete[]) can be called.  An owning smart
  pointer is responsible to call the destructor of the pointee and then to
  free the underlying memory resource.
+
Also each owning pointer has two variants in respect to collaboration with
  garbage collector: _pure owning smart pointers_ are really the owner
  independent of whether GC is turned off or on.  _Regular owning smart
  pointers_ are the owner only if GC is turned off.  If GC is turned on, they
  leave ownership to the GC.
+
Constructors and assignments shall not accept non-owning pointers.  If one
  wants to do that, one needs to use some explicit construct with which he can
  say: ``Here's an object whose owner is technically unknown, but I promise
  it's save to take ownership of that object, so create an unique_ptr (or
  other owning pointer) owning it''.

non-owning pointer:: ...

Concrete Types:

[[unique_ptr]]
(pure_)unique_ptr:: Is the only owner, thus no reference counting needed.  Referred
  obj is of dynamic (non-gc allocated) storage. 

[[shared_ptr]]
(pure_)shared_ptr:: Shared ownership via reference counting.

address / implicit `pointer':: Owning `constant pointer'.  Pointees are:
  - Objects with storage class static.  Owner is one of system / process / thread.
  - Objects with storage class automatic.  Owned by a block/stack.
  - Member objects.  Owned by parent object.
  - +this+, +super+:

[[weak_ptr]]
weak_ptr:: Non-owning, but can be promoted to a shared_ptr.


##   * Mind the swap example
##   * Read http://www.drdobbs.com/cpp/c11-uniqueptr/240002708





[[observer_ptr]]
observer_ptr:: Non-owning.  Compiler ensures at compile time that that the
  owner(s) does not delete the object while the observer_ptr points to it.
  Alternative names: leaser_ptr or renter_ptr.  I fear that the word
  `observer' wrongly implies read only access to the pointee.

// anchor raw_ptr is defined at another place
raw_ptr:: Non-owning.  Primitive type, see <<raw_ptr>>.  Disallowed by
  standard guidelines.  Can point anywhere the other pointers can.  User is
  responsible for mutual exclusion and ownership.  However there still is no
  pointer arithmetic.  That is in order to make pointer alias analysis
  feasible.


General pointer assigning rules:

- If the lifetime of an object o is guaranteed to be longer than the lifetime
  of a non-owning pointer object p, then p can point to o.
- Garbage collector can overtake ownership from owning smart pointers.

Rules to assign an object/pointer to an observer_ptr:

- The observer pointer is a global object, and the referred to object is a
  static object (which will be deleted after to the observer pointer obj),
  or sub-member only following direct or const owning smart pointers.
- The observer pointer is an local object (that includes function
  arguments), and the referred object is either a local object (which is
  owned by stack) or a thread or process static object (owned by process
  or thread respectively) object.  Again including sub-member only
  following direct or const owning smart pointers.
- The observer pointer is a member object and the referred to object is
  another direct member of the same parent object, or it is a child of
  another direct member only following direct member ships, or only
  following const owning pointers.
- The observer pointer is member of a parent object for which the above
  rules (for observer pointer objs) are true.
- in GC mode, observer_ptr can put to what ++gc_new++ returns
- Have methods promise (say via an attribute) that they don't modify any
  non-local owning pointer.  Then a caller can safely pass an owning pointer
  to an argument being an observer pointer.

How to avoid the expensive shared pointers:

- also in a graph, the graph is the owner of the nodes, not the neighbor
  nodes.  So e.g. there would be a singly linked list of nodes using
  unique_ptr, representing the nodes owned by the graph. Each node has also a
  list of non-owning pointers to it's neighboring nodes, which then represents
  the actual graph. Costs space: the additional unique_ptr per node. Costs
  run-time: unique_ptr ctor when inserting a node plus dtor when removing a
  node minus the costs the shared_ptr solution would have had.

Built-in smart-pointer implementation shall be decoupled from
<<memory_management_primitives>> such that also other `allocators' can be
used.

*to-do*:

* Which smart pointer a class (e.g. a class representing a collection)
  internally uses is given as template argument.  E.g. it internally uses
  unique pointers, and data accessor methods return observation pointers.  Or
  it internally uses shared pointers, and data accessor methods return shared
  pointers.  That however means EF needs to have same const_expr which returns
  a type given an input type, and which, regarding the previous example,
  internally has the relation unique pointer -> observer pointer and shared
  pointer -> shared pointer.


[[dereferencing]]
[[addr_of]]
[[pointer_obj_access]]
=== Dereferencing / address of / pointer object access

Dereferencing a pointer is implicit, there is no dereferencing operator.  EF
pointers are treated similar to references in C&plus;&plus;, only that they
are mutable.  Benefits:

* Client of a function needs not to care whether the function expects argument
  as T or *T.  That is important to make calling overloaded operators
  convenient; without, calling an overloaded operator would be very
  cumbersome: ++a = &(b + &c)++ instead the natural ++a = b + c++
* Client of an data object needs not to care whether the object is implemented
  as T or *T.

Say there is a pointer named p and a function named foo returning a pointer
(representing an example of an expression returning a pointer). As explained
before, the name p and the expression ++foo()++ refer to the pointee, not to
the pointer itself.

To access the pointer object itself, e.g. to modify it, the unary prefix
_pointer object access_ operator +@+ is used.  In the example above, ++@p++
and ++@foo()++ denote the pointer object, not the pointee.



Since the address of operator in C / C&plus;&plus; is only used to let a
pointer object point to a given object, that operator is not needed in EF. 


== Compilation

[[ctconst]]
[[ct_execution]]
=== Compile time execution / ctconst (aka constexpr)

Extend Cpp11 (I don't know what Cpp14 offers) concept of constexpr, but
probably name it ++ctconst++.  The code the compiler generates can also be
executed right away.  Why restrict that in any way?  Maybe it gets too
difficult to write good tools (analysis, semantic aware tools for IDEs, etc).

Difficult for cross compilers?  The code really being generated cannot be
executed.  The code executed while compiling is either in the host machine
code or in some byte code the compiler can execute.

Allow using const and temporary objects.  That makes it possible that we can
call methods on literals, being really of a given class type (everything is an
object in EF), and the calls are evaluated at compile time.

The `normal' compiler receives built-in literals from the execution of the
code the meta compiler produced.

[[sharp_prefix]]
==== # prefix guideline

Consider having the guideline to use # as first char for each name (keyword or
identifier) which is ctconst.  Not only would that mean that only by looking
at a name one would know that there are no run time costs, but also that it
looks quite familiar to people with a C background: e.g.  ++#include++ (or
++#import++), ++#if++ (conditional compilation), .... Note that a hash
followed by an exclamation mark is a comment, see <<comments>>.


==== Conditional compiling

constexpr are evaluated at compile time.  Using that with const conditional
expression and put declaration statements into the clauses controlled by the
conditional expression we get conditional declarations.


==== Preprocessor / Macros

* EF shall provide macros, but discourage their use.  They only can be enabled
  by a style guide compile switch.
* If a language has macros / a preprocessor, it is apparently much harder to
  write tools like static code analysis or refactoring tools.
* If there is no preprocessor, how to I get __FILE__, __LINE__, __FUNC__? For
  __FUNC__ maybe something like ++thisfunc.name()++
* Even if EF has expressions evaluated at compile time which conditionally
  define/declare stuff, than macros still can assemble arbitrary text, .e.g
  only part of expressions
* Use M4?
* As separator for parameters of a macro call, interpreted by preprocessor,
  use something which is not part of the EF language.  E.g. if EF knows comma
  (,) but not semicolon (;), then e.g. the preprocessor uses semicolon to
  separate arguments.  In C&plus;&plus; its not easily possibly and sometimes
  not at all to pass an argument containing a comma.


== Namespaces in general

Namespaces can be created using a list expression, say ++namespace...$++.
That would be roughly equivalent to C&plus;&plus;'s ++namespace {...}++.


Classes/Modules are also namespaces.

* Somehow make it hard to accidentally shadow a name and/or to accidentally
  refer to another name as intended.  E.g. warnings if a newly introduced name
  shadows another one.  To really to that the user needs to explicitly state
  that.  I.e. an declaration in EF could have an +shadows+ attribute.  When
  that attribute is used without really shadowing a name, that too results in
  a warning.  As always, (specific) warnings can be turned off or turned into
  errors.

* When importing a namespace and a newly imported name shadows another one,
  shall this result in a warning?  Must the user explicitly state which names
  he approves/allows to shadow others. 

* When calling a method, within the argument list the name space of the
  method's class is the top namespace.  That way one is not forced to qualify
  names defined in that class which one want's to pass as argument.  A typical
  use case are enumerations.  What if the user does not want to import that
  namespace within the argument list -- shall EF give him a choice?  What if
  the act of importing the namespace would shadow names -- does that result in
  a warning -- or only if the names used within the argument list are ones
  that where auto-imported and now shadow others?

* Consider that private members are not in the scope of sub classes, or that
  members of subclasses can shadow them without warning / error.  After all,
  private members are implementation details which shall have no impact on
  other classes, inclusive subclasses, when changed.  However when adding a
  private member can cause a subclass not to compile because the subclass
  already has a member of the same name, that principle is broken.  *to-do*:
  What about virtual private method (possibly abstract), where it is expected
  that a subclass overrides them, but we still want to prevent the subclass
  from invoking it -- maybe a too rare case?

* Have the same namespace for identifiers for objects (including code objects)
  and for types and label and whatever.  This is simpler for the parser
  (closer to being context free), and also simpler for most human brains: one
  name meaning different things just is confusing.



== Composable / extendable language

=== Composable language

Each of these features the user can turn on/off by options:

- Variable sized objects, in particular arrays.  Because that introduces a
  `hidden' indirection.  So a variant would be to still allow the variable
  sized objects (C, being _the_ system language, also allows them), but one
  would be required to use a syntax where the indirection is clearly visible.
- Member method with implicit this argument, i.e. e.g. the this keyword must be
  given explicitly as first argument.  How about calling a member method?
- That yet unnamed default ``implementation hiding'' of smart pointers (which
  at the side of referencing the pointer hides the cost of dereferencing).
- Virtual methods
- [constructors: user can already omit calling a constructor by special
  initializers like e.g. `nop_init']
- RAII / destructors
- Exceptions
- Bounds checking which cannot be done at compile time, i.e. which must be
  done at run time.
- Restrictions on operations allowed on pointers which make pointer alias
  analysis feasible
- Owning smart pointers
- Garbage collector

That however makes designing the standard library difficult, if the library
design does not know that the user allows and what not.  Features which have
only local costs (within a method) should be allowed in the library, that is
an implementation decision.  If the user doesn't like it, he can take another
library implementation.  Also have two parts of the library, spoken in
analogy: a C part and a C&plus&plus/STL part.  Methods which can return an
error have two versions, one using exceptions and one using the C way.

One of the goals of this ``composable language'' topic is to make it feasible
that EF can be used, if used with the required (command line) options, as a
system language with all run time costs directly visible, i.e. without any
`hidden' run time costs.  EF would then be like a ``better assembler'', or
even hopefully ``a better C''.


=== Extendable language
Literals such as strings, arithmetic, collection are just very basic from a
language point of view.  However the language allows to create aliases, and
the EF standard then supplies a number of them.  List literals l[...], map
literals m[...] etc only make use of some meta language which lets the user
define such literal constructs.


== Exceptions

See chapter 'Embedded System constraints'

Allow to disable them for users where footprint size is most important.  But
what will happen then to the signature of library functions?  Do we always
need two versions, one using return codes and one using exceptions (and using
the return value for something which allows the caller to build nice
expressions)?.  If so, probably the exception version should be the one having
to pay the penalty of having two versions, if there is a penalty at all.
Because the return code version is the one for the embedded system with hard
constrains, thus a penalty is not affordable.

When to use exceptions?

Some say Use exceptions correctly: to report an unexpected use case.  When the
function could not do what it was asked to do.  Don't use it in normal use
cases.  An exception should actually never occur at all.  But that does mean
that the N caller of `divide' is supposed to check for themselves that divisor
is not 0 (OK, if they can and want to react, they have to write the code
anyway, the question is only before the call to prevent the call or after the
call in the catch clause).  Likewise for opening a file
-- here I think it would even be the wrong solution to do it like `if
!fileexists open' because naturally between the fileexists and the open the
file can vanish.

Others say, I think ruby or python, that you should always first just try and
if it fails, try to react in the catch handler.


- As I think Stroustrup said: The whole error handling theme _is_ complex,
  don't blame the exceptions.
- Caller can decide that all/certain exceptions result in an die right away.
  E.g. because caller thinks he fulfills all preconditions or because he (and
  no one else in the call hierarchy) doesn't write a catch handler.  However
  then each exceptions needs to be translatable into a integer and or a string
  which can then be automatically printed.  That printer is user definable,
  e.g. through overload or registering a callback aka hook.
- As in Java, have an obligatory throws clause
- We can define name's for sets of exceptions, usable for throws part of
  function signature


[[throws_clause]]
=== Throws clause

----------------------------------------------------------------------
throws_clause = 'throws (type_expr* | 'none);
----------------------------------------------------------------------

++throws none++ means none what so ever.  *to-do:* How about introducing a new
keyword +nothrow+ which can be used in lieu of ++throws none++.


[[exception_safety_guarantees]]
=== Exception safety guarantees

It would be nice if methods could declare their intended exception safety
guarantee, and the compiler could verify that it is true.  E.g. by adding new
function modifiers +strong_es+, +basic_es+, +no_es+ (es = exception safety).
The no-throw exception safety guarantee is specified in the <<throws_clause>>.


[[templates]]
== Templates / generic programming
Each template argument has an attribute which defines whether that template
argument contributes to define a distinct type or not.  That is probably
needed for variable sized objects, see <<variable_sized_obj>>.

Similarly but probably yet different: topic of efficient implementation of
templates.  E.g. when imaging cpp unique_ptr: there only one implementation in
the program text sequence is required; that single one can serve all concrete
types since they only differ in the type pointed to.

Template static objects.  There is only one object in the whole program (in
C&plus;&plus;, given a class static member in a templatized class, there is
one object per template instance).

=== Defining a parameterized type / function

The definition a paramterized type differs only from the definition of a
non-paramterized type that the former contains a +type_params+ and the later
does not.  Here only +type_params+ is described.

----------------------------------------------------------------------
type_params = \< ( new_identifier [\: metatype_for_type_param] \,{l?})* \>;
metatype_for_type_param =
  type_bounds | <1>
  type_expr;    <2>
type_bounds = ... ;
----------------------------------------------------------------------

<1> The argument for this parameter must be a +type_expr+ within the given
    bounds.
<2> The argument for this parameter is an +expr+ of the given type.


=== Referring to a parameterized type / function

----------------------------------------------------------------------
type_args = \< (type_arg \,{l?})* \>;
type_arg = type_expr | explicit_rt_expr;
----------------------------------------------------------------------

It's much more common to pass types than to pass data objects.  Thus the
default is +type_expr+;  when you need to pass a data object, i.e. an +expr+,
you need to that via the +explicit_rt_expr+ wrapper.


== Optimizations

See book Writing Efficient Programs.  See also <<cheap_destructors>>.


=== Copy elision

...


=== Lazy evaluation

If its true that it is not applicable in an hard-real time environment, then
provide compiler switch to turn it off.  However would that work?  Probably
the caller module and the module implementing the function must be compiled
with the same compiler switch.


== Concurrency


[[excl_shared_access]]
=== Object property `exclusive/shared access'

See also <<obj_properties>>.  Member objects' exclusive/shared access property
is also determined by parent object's exclusive/shared access property.  If
parent allows shared access, then so must member.  If parent has exclusive
access, then a member still can have shared access, e.g. because the user
chooses an implementation based on multiple threads.


=== Reentrancy

.to-do:
- Does it make sense to mark code chunks as reentrant / non-reentrant?
- How to ensure a non-reentrant code chunk is not called by multiple threads?


=== Threads (user-level & kernel-level) / processes

...


=== Atomic operations

...

=== Locks / Semaphores ...

Provide automatic locks/... around shared resources if wished, e.g. with a
keyword stating that this is a shared object and that it shall have an
autolock.  see also <<obj_properties>>.  User may not wish that because he
wants to bundle multiple accesses to shared resources in one critical section.

=== Shared resources

Potentially but not necessarily (i.e. parts of these resources can also be
owned exclusively by one thread) shared by threads, common to one process:

Memory:: See <<obj_properties>> and <<smart_pointers>> for properties of objects / smart
pointers which aid in the topic of concurrency.
File descriptors:: ...
Signals:: ...

Shared by processes:

Memory:: ...
...

=== IPC (Inter process communication)

...

== Library

=== Provided by library vs built-in
- Optimizers & verifiers can take more advantages when things are built-in,
  right? 
- In most cases there are multiple ways to implement a given function
  signature.  Which implementation is the best depends on the problem at
  hand.  Only the user knows the problem, so he might want to choose the
  library implementation that suits his problem best.

=== Iterators
- Know their container, most of all know the bounds of the container

=== Algorithms
- Primarily work with collections, not with iterator pairs

=== Localization / Internationalization / character encoding

...


== Interaction

...


=== ABI

...


=== Talk to C API

...


=== Inline Assembler Snippets

...


[[tools]]
== Tools around

EF tries to support tools as e.g. optimizers and verifiers by making pointer
alias analysis feasible (at least more feasible than in C or C&plus;&plus;) by
only providing constructs where analysis has a change to follow where pointers
point to.  E.g. by 1) not providing pointer arithmetic (however there are
iterators) and 2) not providing integer->pointer casts.

When D has guidelines/rules how to name unnamed/temporary objects / code
chunks, then tools can profit.  The semantic intelligence of an IDE can show
them.  Also probably needed in call tree visualizations where unnamed code
chunks are part of.  In the debugger I want to visualize return values of
functions or even every expression.


=== Debugger

- Be able to display at least return value of functions call.  Maybe even the
  unnamed temporary result of each expression.
- Be able to debug all constructs (macros, templates, closures, lambdas, ...)


=== Optimizer / Verifier

See what Clang Static Analyzer does.


=== Valgrind / LLVM & Co

...


=== Profiler

The guideline is to always use the `automatic'/`smart' classes, never the
raw/built-in types like raw arrays, raw pointers etc.  Only when a profiler
shows that a certain part of the code has efficiency issues those should be
considered.


=== IDEs can have semantic understanding

Plugins for QTCreator, Eclipse, MS Studio, Emacs, Vim.  To my current
understanding, QTCreator is more often used for development of applications on
embedded systems than Eclipse, thus first start with QTCreator.


=== Pretty printer aka beautifier

...


== Style Guidelines

By default enforce some white rules.  This enforcement can be turned off by
compile switch.  Nearly all style guides agree that the actual style is not
that important, any programmer can quickly get used to any style, only
consistency is important.  When the language mildly enforces a style then
there is a high chance of consistency.

Also enforce some naming style?  Uppercase for type names, class members end
or start with underscore....

By default the warning level is maximum, and warnings are treated as 


== Misc

* ; or , build expression lists (aka/similar compound statement).  The value
  of the whole thing is the value of the last element.  It follows that the
  value of a function body is the value of the last element, i.e. a return
  statement is no longer needed.  Allowing to omit the return statement
  especially makes small lambdas more concise/readable.
* Via compile switches one can choose whether mnemonic keywords or full/long
  keywords are prohibited.  The default is to use mnemonic keywords.  That
  results in shorter code, the reader better sees the important things in the
  code, and by being mnemonic its very unlikely that the maintainer does not
  remember the meanings of the keywords.  Many languages successfully use
  mnemonic abbreviations: ++struct++, ++defun++, ...
* As in python/Perl tuples/lists everywhere: (a,b,c) = foo_returning_3
* Read again (google) ``C and C&plus;&plus; are not context free'' --
  Trevor Jim.
* Let me initially a local var by passing it as output param to a function
  call fun void( int&, int&); fun bar() -> void { foo( int var flori nop_init,
  int var edi nop_init ); cout << flori << edi; }

As in Python, make it possible that a list of variables are initialized by a list
----------------------------------------------------------------------
[var i as auto, var j as auto] = gettwo();
[i,j] = gettwo();
!!!! must work for any type of collection gettwo returns !!!!
the explicit version would probably be
std::tuple<const int&,const double&>(i,j) = gettwo();
----------------------------------------------------------------------

== Bibliography

[bibliography]
- [[[TCppStd]]] The ISO C&plus;&plus; standard (for C&plus;&plus;11). In
  short just `the standard'.  Officially known as `ISO International Standard
  ISO/IEC 14882:2011(E) – Programming Language
  C&plus;&plus;'. http://isocpp.org/std/the-standard.

//  LocalWords:  decl malloc IPC laterinit laterctor alist sa ary arg args
//  LocalWords:  del foreach OverrideAndDelete Inmutable endof Structs vals
//  LocalWords:  allocator allocators addr TCppStd IEC params param jumptable
//  LocalWords:  funt tfun prvalue unstored xvalue glvalue autoimpl nothrow
//  LocalWords:  tnull
