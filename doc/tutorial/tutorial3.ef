#!/usr/bin/env efc
# 
# The EF programming language tutorial part 3
# ===========================================
#
# Expression sequences (aka blocks)
# ---------------------------------
# Demo part 2 and the following demonstrate
# - The value of an expression sequence (aka block) is the value of its last
#   expression. In body of the square method of demo 2 the expression sequence
#   consists of just one expression 'x * x'. In the example below, it consists
#   of five expressions, in the example one per line.
# - The return value of a function is the value of its top level expression
#   sequence (aka block). 
# - The elements (being expressions) of an expression sequence are separated
#   by nothing. However you can optionally separate them by commas. Also a
#   trailing comma is allowed but not required. 'a b' and 'a , b' in EF are
#   equivalent to 'a , b' in C/C++.


# Data object definitions
# -----------------------
# The example below shows how values and variables are defined. A value is an
# immutable (aka const) variable. 'Data object' is the generic term for
# variable and value.
fun square_minus_four: (x:int) -> int =
   val square: int = x * x;
   var tmp: int = square - 1;
   tmp = tmp - 1
   tmp = tmp - 1,
   tmp = tmp - 1,
;

# The type in a val/var definition can be omitted if the type can be inferred
# (similar to the auto keyword in C++) from the initializer. The syntax 'a :=
# b' is short for 'val a: = b;'. Using val(ue) is preferred over using
# var(iable), hence the short form is for val(ue) instead (var)iable.
#
# The current version of EF cannot really do type inference, but since the
# only type currently is int, deducing the correct type is trivial since its
# always int.
fun square_minus_four_v2: (x:int) -> int =
   squaretmp := x * x;
   var tmp: = square - 1;
   tmp - 3
;

square_minus_four(3)
