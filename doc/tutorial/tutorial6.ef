#!/usr/bin/env efc
# 
# The EF programming language tutorial part 6
# ===========================================
# 
# Everything is an expressions -- no statements
# ---------------------------------------------
# 
# In EF everything is an expression. There are no statements. Also a control
# flow construct like 'if cond_expr: then_expr else else_expr;' is actually an
# expression having a value. If cond_expr is true, then the overall value
# equals to then_expr, and if cond_expr is false then the overall value equals
# to else_expr.
x:=1  y:=2  z:=3
foo1 := if x: y else z;

# Also definitions and declarations like 'val foo: int = 3;' and 'decl fun
# foo: () -> int;' are expressions. Their value is that of the identifier
# being declared / defined.


# Conceptually every construct is a call 
# --------------------------------------
# Conceptually, from syntax point of view, everything, also flow control
# constructs, declarations, definitions etc., are function calls like
# 'foo(arg1,arg2)'. Its only that EF provides another syntax which however is
# actually pretty close to the well known function call syntax
# 'foo(arg1,arg2)'. Its only that a) the opening parenthesis is not needed
# since for a keyword that is implicit b) other argument separators instead
# comma are used - eg ':' or 'else' or '->' c) semicolon is used instead of
# the closing parenthesis as closing delimiter.
# 
#                | func  open   arg1    arg    arg2  arg     arg3  close
#                | name  deli-          sepa-        sepa-         deli-
#                |       miter          rator        rator         miter
#                |------------------------------------------------------
# EF syntax 1    | if            a      [:]     b    else     c      ;
# EF syntax 2    | if     (      a      [:]     b    else     c      )
# classic syntax | if     (      a       ,      b     ,       c      )
#
# Alternatively EF also lets you write all expressions in the call syntax with
# open/close parenthesis like 'if(a : b else c)'. Maybe a future version also
# allows the 'pure' classic syntax with always commas as separators like this
# 'if(a , b , c)'.
# 
# the following three lines are equivalent
val foo2 =  if x: y else z; + 3 ;
val foo3 =  if(x: y else z) + 3 ;
val foo4 = {if(x: y else z) + 3};

# Also operators can be written in the call syntax.
# operator syntax       call syntax
  x+y                   +(x,y)

# For most operators any amount of arguments can be passed in the call
# syntax. E.g '*(u,v,w,x,y,z)'. For zero and one argument the following
# definitions apply:
  0                     +()
  0                     -()
  1                     *()
                       #/() is invalid, / needs at least two operands
  x                     +(x)
  0-x                   -(x) # "-x" for unary minus is invalid in EF
  x                     *(x)
                       #/(x) is invalid, / needs at leat two operands
